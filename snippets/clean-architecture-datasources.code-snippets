{
  "HTTP Remote Data Source": {
    "prefix": "clean-http-datasource",
    "description": "Complete HTTP remote data source with Dio and error handling",
    "body": [
      "import 'package:dio/dio.dart';",
      "import 'package:dartz/dartz.dart';",
      "",
      "import '../../domain/failures/${1:domain}_failure.dart';",
      "import '../models/${2:user}_dto.dart';",
      "import '../models/api_response.dart';",
      "import '${2:user}_remote_datasource.dart';",
      "",
      "class ${3:User}HttpDataSource implements ${3:User}RemoteDataSource {",
      "  final Dio _dio;",
      "  final String _baseUrl;",
      "",
      "  const ${3:User}HttpDataSource({",
      "    required Dio dio,",
      "    required String baseUrl,",
      "  }) : _dio = dio,",
      "       _baseUrl = baseUrl;",
      "",
      "  String get _endpoint => '\\$_baseUrl/${4:users}';",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, ${2:User}Dto>> create(${2:User}Dto ${5:user}Dto) async {",
      "    try {",
      "      final response = await _dio.post(",
      "        _endpoint,",
      "        data: ${5:user}Dto.toJson(),",
      "        options: Options(",
      "          headers: {'Content-Type': 'application/json'},",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<${2:User}Dto>(",
      "        response,",
      "        (data) => ${2:User}Dto.fromJson(data as Map<String, dynamic>),",
      "      );",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to create ${5:user}: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, ${2:User}Dto>> getById(String id) async {",
      "    try {",
      "      final response = await _dio.get(",
      "        '\\$_endpoint/\\$id',",
      "        options: Options(",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<${2:User}Dto>(",
      "        response,",
      "        (data) => ${2:User}Dto.fromJson(data as Map<String, dynamic>),",
      "      );",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to get ${5:user}: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, List<${2:User}Dto>>> getAll() async {",
      "    try {",
      "      final response = await _dio.get(",
      "        _endpoint,",
      "        options: Options(",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<List<${2:User}Dto>>(",
      "        response,",
      "        (data) => (data as List<dynamic>)",
      "            .map((item) => ${2:User}Dto.fromJson(item as Map<String, dynamic>))",
      "            .toList(),",
      "      );",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to get all ${4:users}: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, ${2:User}Dto>> update(${2:User}Dto ${5:user}Dto) async {",
      "    try {",
      "      final response = await _dio.put(",
      "        '\\$_endpoint/\\${${5:user}Dto.id}',",
      "        data: ${5:user}Dto.toJson(),",
      "        options: Options(",
      "          headers: {'Content-Type': 'application/json'},",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<${2:User}Dto>(",
      "        response,",
      "        (data) => ${2:User}Dto.fromJson(data as Map<String, dynamic>),",
      "      );",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to update ${5:user}: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> delete(String id) async {",
      "    try {",
      "      final response = await _dio.delete(",
      "        '\\$_endpoint/\\$id',",
      "        options: Options(",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<Unit>(",
      "        response,",
      "        (_) => unit,",
      "      );",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to delete ${5:user}: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, List<${2:User}Dto>>> search({",
      "    String? query,",
      "    Map<String, dynamic>? filters,",
      "    String? sortBy,",
      "    bool ascending = true,",
      "    int? limit,",
      "    int? offset,",
      "  }) async {",
      "    try {",
      "      final queryParams = <String, dynamic>{};",
      "      ",
      "      if (query != null) queryParams['q'] = query;",
      "      if (sortBy != null) {",
      "        queryParams['sort'] = ascending ? sortBy : '-\\$sortBy';",
      "      }",
      "      if (limit != null) queryParams['limit'] = limit;",
      "      if (offset != null) queryParams['offset'] = offset;",
      "      if (filters != null) queryParams.addAll(filters);",
      "",
      "      final response = await _dio.get(",
      "        '\\$_endpoint/search',",
      "        queryParameters: queryParams,",
      "        options: Options(",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<List<${2:User}Dto>>(",
      "        response,",
      "        (data) => (data as List<dynamic>)",
      "            .map((item) => ${2:User}Dto.fromJson(item as Map<String, dynamic>))",
      "            .toList(),",
      "      );",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to search ${4:users}: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, PaginatedDtoResult<${2:User}Dto>>> getPaginated({",
      "    required int page,",
      "    required int pageSize,",
      "    String? sortBy,",
      "    bool ascending = true,",
      "    Map<String, dynamic>? filters,",
      "  }) async {",
      "    try {",
      "      final queryParams = <String, dynamic>{",
      "        'page': page,",
      "        'page_size': pageSize,",
      "      };",
      "      ",
      "      if (sortBy != null) {",
      "        queryParams['sort'] = ascending ? sortBy : '-\\$sortBy';",
      "      }",
      "      if (filters != null) queryParams.addAll(filters);",
      "",
      "      final response = await _dio.get(",
      "        _endpoint,",
      "        queryParameters: queryParams,",
      "        options: Options(",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handlePaginatedResponse(response);",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to get paginated ${4:users}: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, ${2:User}Dto?>> findByEmail(String email) async {",
      "    try {",
      "      final response = await _dio.get(",
      "        '\\$_endpoint/email/\\$email',",
      "        options: Options(",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      if (response.statusCode == 404) {",
      "        return right(null);",
      "      }",
      "",
      "      return _handleResponse<${2:User}Dto?>(",
      "        response,",
      "        (data) => data != null ? ${2:User}Dto.fromJson(data as Map<String, dynamic>) : null,",
      "      );",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to find ${5:user} by email: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, bool>> exists(String id) async {",
      "    try {",
      "      final response = await _dio.head(",
      "        '\\$_endpoint/\\$id',",
      "        options: Options(",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return right(response.statusCode == 200);",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to check ${5:user} existence: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, bool>> existsByEmail(String email) async {",
      "    try {",
      "      final response = await _dio.head(",
      "        '\\$_endpoint/email/\\$email/exists',",
      "        options: Options(",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return right(response.statusCode == 200);",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to check email existence: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, List<${2:User}Dto>>> createMany(List<${2:User}Dto> ${6:users}) async {",
      "    try {",
      "      final response = await _dio.post(",
      "        '\\$_endpoint/batch',",
      "        data: {'${4:users}': ${6:users}.map((e) => e.toJson()).toList()},",
      "        options: Options(",
      "          headers: {'Content-Type': 'application/json'},",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<List<${2:User}Dto>>(",
      "        response,",
      "        (data) => (data as List<dynamic>)",
      "            .map((item) => ${2:User}Dto.fromJson(item as Map<String, dynamic>))",
      "            .toList(),",
      "      );",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to create multiple ${4:users}: \\$e'));",
      "    }",
      "  }",
      "",
      "  // Private helper methods",
      "  Either<${1:Domain}Failure, T> _handleResponse<T>(",
      "    Response response,",
      "    T Function(dynamic) parser,",
      "  ) {",
      "    try {",
      "      if (response.statusCode == null) {",
      "        return left(const ${1:Domain}Failure.networkError('No response status'));",
      "      }",
      "",
      "      if (response.statusCode! >= 200 && response.statusCode! < 300) {",
      "        final data = response.data;",
      "        if (data is Map<String, dynamic> && data.containsKey('data')) {",
      "          return right(parser(data['data']));",
      "        }",
      "        return right(parser(data));",
      "      }",
      "",
      "      return left(_handleHttpError(response));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.parsingError('Failed to parse response: \\$e'));",
      "    }",
      "  }",
      "",
      "  Either<${1:Domain}Failure, PaginatedDtoResult<${2:User}Dto>> _handlePaginatedResponse(",
      "    Response response,",
      "  ) {",
      "    try {",
      "      if (response.statusCode == null || response.statusCode! < 200 || response.statusCode! >= 300) {",
      "        return left(_handleHttpError(response));",
      "      }",
      "",
      "      final paginatedResponse = PaginatedApiResponse<${2:User}Dto>.fromJson(",
      "        response.data as Map<String, dynamic>,",
      "        (json) => ${2:User}Dto.fromJson(json as Map<String, dynamic>),",
      "      );",
      "",
      "      return right(PaginatedDtoResult(",
      "        items: paginatedResponse.data,",
      "        totalCount: paginatedResponse.pagination.totalItems,",
      "        page: paginatedResponse.pagination.currentPage,",
      "        pageSize: paginatedResponse.pagination.perPage,",
      "      ));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.parsingError('Failed to parse paginated response: \\$e'));",
      "    }",
      "  }",
      "",
      "  ${1:Domain}Failure _handleDioError(DioException e) {",
      "    switch (e.type) {",
      "      case DioExceptionType.connectionTimeout:",
      "      case DioExceptionType.sendTimeout:",
      "      case DioExceptionType.receiveTimeout:",
      "        return const ${1:Domain}Failure.connectionTimeout();",
      "",
      "      case DioExceptionType.connectionError:",
      "        return const ${1:Domain}Failure.noInternetConnection();",
      "",
      "      case DioExceptionType.badResponse:",
      "        return _handleHttpError(e.response);",
      "",
      "      case DioExceptionType.cancel:",
      "        return const ${1:Domain}Failure.cancelled();",
      "",
      "      case DioExceptionType.unknown:",
      "      default:",
      "        return ${1:Domain}Failure.networkError(e.message);",
      "    }",
      "  }",
      "",
      "  ${1:Domain}Failure _handleHttpError(Response? response) {",
      "    if (response == null) {",
      "      return const ${1:Domain}Failure.networkError('No response received');",
      "    }",
      "",
      "    switch (response.statusCode) {",
      "      case 400:",
      "        return ${1:Domain}Failure.validationError(",
      "          field: 'request',",
      "          message: _extractErrorMessage(response.data),",
      "        );",
      "",
      "      case 401:",
      "        return const ${1:Domain}Failure.unauthorizedAccess();",
      "",
      "      case 403:",
      "        return const ${1:Domain}Failure.forbidden();",
      "",
      "      case 404:",
      "        return const ${1:Domain}Failure.notFound('Resource');",
      "",
      "      case 409:",
      "        return ${1:Domain}Failure.conflictError(",
      "          _extractErrorMessage(response.data),",
      "        );",
      "",
      "      case 422:",
      "        return ${1:Domain}Failure.validationError(",
      "          field: 'data',",
      "          message: _extractErrorMessage(response.data),",
      "        );",
      "",
      "      default:",
      "        if (response.statusCode! >= 500) {",
      "          return ${1:Domain}Failure.serverError(",
      "            statusCode: response.statusCode!,",
      "            message: _extractErrorMessage(response.data),",
      "          );",
      "        }",
      "        return ${1:Domain}Failure.unexpected(",
      "          'HTTP \\${response.statusCode}: \\${_extractErrorMessage(response.data)}',",
      "        );",
      "    }",
      "  }",
      "",
      "  String _extractErrorMessage(dynamic data) {",
      "    if (data is Map<String, dynamic>) {",
      "      return data['message'] ?? data['error'] ?? 'Unknown error';",
      "    }",
      "    return data?.toString() ?? 'Unknown error';",
      "  }",
      "",
      "  // Additional methods implementation...",
      "  @override",
      "  Future<Either<${1:Domain}Failure, List<${2:User}Dto>>> getActive() {",
      "    return search(filters: {'active': true});",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, List<${2:User}Dto>>> getRecent({int days = 7}) {",
      "    final cutoffDate = DateTime.now().subtract(Duration(days: days));",
      "    return search(filters: {'created_after': cutoffDate.toIso8601String()});",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> deleteMany(List<String> ids) async {",
      "    try {",
      "      final response = await _dio.delete(",
      "        '\\$_endpoint/batch',",
      "        data: {'ids': ids},",
      "        options: Options(",
      "          headers: {'Content-Type': 'application/json'},",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<Unit>(response, (_) => unit);",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to delete multiple ${4:users}: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, List<${2:User}Dto>>> updateMany(List<${2:User}Dto> ${6:users}) async {",
      "    try {",
      "      final response = await _dio.put(",
      "        '\\$_endpoint/batch',",
      "        data: {'${4:users}': ${6:users}.map((e) => e.toJson()).toList()},",
      "        options: Options(",
      "          headers: {'Content-Type': 'application/json'},",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<List<${2:User}Dto>>(",
      "        response,",
      "        (data) => (data as List<dynamic>)",
      "            .map((item) => ${2:User}Dto.fromJson(item as Map<String, dynamic>))",
      "            .toList(),",
      "      );",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to update multiple ${4:users}: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, int>> count([Map<String, dynamic>? filters]) async {",
      "    try {",
      "      final response = await _dio.get(",
      "        '\\$_endpoint/count',",
      "        queryParameters: filters,",
      "        options: Options(",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<int>(",
      "        response,",
      "        (data) => data is int ? data : int.parse(data.toString()),",
      "      );",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to count ${4:users}: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Map<String, int>>> getStatistics() async {",
      "    try {",
      "      final response = await _dio.get(",
      "        '\\$_endpoint/statistics',",
      "        options: Options(",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<Map<String, int>>(",
      "        response,",
      "        (data) => Map<String, int>.from(data as Map),",
      "      );",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to get ${4:users} statistics: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, String>> uploadProfileImage(",
      "    String ${5:user}Id,",
      "    String imagePath,",
      "  ) async {",
      "    try {",
      "      final formData = FormData.fromMap({",
      "        'image': await MultipartFile.fromFile(imagePath),",
      "      });",
      "",
      "      final response = await _dio.post(",
      "        '\\$_endpoint/\\${${5:user}Id}/profile-image',",
      "        data: formData,",
      "        options: Options(",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<String>(",
      "        response,",
      "        (data) => data['image_url'] as String,",
      "      );",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to upload profile image: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> deleteProfileImage(String ${5:user}Id) async {",
      "    try {",
      "      final response = await _dio.delete(",
      "        '\\$_endpoint/\\${${5:user}Id}/profile-image',",
      "        options: Options(",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<Unit>(response, (_) => unit);",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Failed to delete profile image: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, ${2:User}Dto>> authenticate(",
      "    String email,",
      "    String password,",
      "  ) async {",
      "    try {",
      "      final response = await _dio.post(",
      "        '\\$_baseUrl/auth/login',",
      "        data: {'email': email, 'password': password},",
      "        options: Options(",
      "          headers: {'Content-Type': 'application/json'},",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<${2:User}Dto>(",
      "        response,",
      "        (data) => ${2:User}Dto.fromJson(data['${5:user}'] as Map<String, dynamic>),",
      "      );",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Authentication failed: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> resetPassword(String email) async {",
      "    try {",
      "      final response = await _dio.post(",
      "        '\\$_baseUrl/auth/reset-password',",
      "        data: {'email': email},",
      "        options: Options(",
      "          headers: {'Content-Type': 'application/json'},",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<Unit>(response, (_) => unit);",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Password reset failed: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> verifyEmail(String token) async {",
      "    try {",
      "      final response = await _dio.post(",
      "        '\\$_baseUrl/auth/verify-email',",
      "        data: {'token': token},",
      "        options: Options(",
      "          headers: {'Content-Type': 'application/json'},",
      "          validateStatus: (status) => status != null && status < 500,",
      "        ),",
      "      );",
      "",
      "      return _handleResponse<Unit>(response, (_) => unit);",
      "    } on DioException catch (e) {",
      "      return left(_handleDioError(e));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.unexpected('Email verification failed: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Stream<Either<${1:Domain}Failure, ${2:User}Dto>> subscribeToUpdates(String id) {",
      "    // Implementation would depend on your WebSocket/SSE setup",
      "    throw UnimplementedError('Real-time subscriptions not implemented');",
      "  }",
      "",
      "  @override",
      "  Stream<Either<${1:Domain}Failure, List<${2:User}Dto>>> subscribeToAll() {",
      "    // Implementation would depend on your WebSocket/SSE setup",
      "    throw UnimplementedError('Real-time subscriptions not implemented');",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, bool>> healthCheck() async {",
      "    try {",
      "      final response = await _dio.get(",
      "        '\\$_baseUrl/health',",
      "        options: Options(",
      "          validateStatus: (status) => status != null && status < 500,",
      "          receiveTimeout: const Duration(seconds: 5),",
      "        ),",
      "      );",
      "",
      "      return right(response.statusCode == 200);",
      "    } catch (e) {",
      "      return left(const ${1:Domain}Failure.networkError('Health check failed'));",
      "    }",
      "  }",
      "}",
      "$0"
    ]
  },

  "Hive Local Data Source": {
    "prefix": "clean-hive-datasource",
    "description": "Complete Hive local data source for caching",
    "body": [
      "import 'package:dartz/dartz.dart';",
      "import 'package:hive/hive.dart';",
      "",
      "import '../../domain/failures/${1:domain}_failure.dart';",
      "import '../models/${2:user}_dto.dart';",
      "import '${2:user}_local_datasource.dart';",
      "",
      "class ${3:User}HiveDataSource implements ${3:User}LocalDataSource {",
      "  static const String _boxName = '${4:users}_cache';",
      "  static const String _metaBoxName = '${4:users}_meta';",
      "  static const String _syncBoxName = '${4:users}_sync';",
      "",
      "  late final Box<Map<dynamic, dynamic>> _${4:users}Box;",
      "  late final Box<Map<dynamic, dynamic>> _metaBox;",
      "  late final Box<Map<dynamic, dynamic>> _syncBox;",
      "",
      "  ${3:User}HiveDataSource() {",
      "    _${4:users}Box = Hive.box<Map<dynamic, dynamic>>(_boxName);",
      "    _metaBox = Hive.box<Map<dynamic, dynamic>>(_metaBoxName);",
      "    _syncBox = Hive.box<Map<dynamic, dynamic>>(_syncBoxName);",
      "  }",
      "",
      "  static Future<void> init() async {",
      "    await Hive.openBox<Map<dynamic, dynamic>>(_boxName);",
      "    await Hive.openBox<Map<dynamic, dynamic>>(_metaBoxName);",
      "    await Hive.openBox<Map<dynamic, dynamic>>(_syncBoxName);",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> cache(${2:User}Dto ${5:user}Dto) async {",
      "    try {",
      "      await _${4:users}Box.put(${5:user}Dto.id, ${5:user}Dto.toJson());",
      "      await _metaBox.put('\\${${5:user}Dto.id}_cached_at', {",
      "        'timestamp': DateTime.now().toIso8601String(),",
      "      });",
      "      return right(unit);",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> cacheAll(List<${2:User}Dto> ${6:users}) async {",
      "    try {",
      "      final batch = <String, Map<dynamic, dynamic>>{};",
      "      final metaBatch = <String, Map<dynamic, dynamic>>{};",
      "      final timestamp = DateTime.now().toIso8601String();",
      "",
      "      for (final ${5:user} in ${6:users}) {",
      "        batch[${5:user}.id] = ${5:user}.toJson();",
      "        metaBatch['\\${${5:user}.id}_cached_at'] = {'timestamp': timestamp};",
      "      }",
      "",
      "      await _${4:users}Box.putAll(batch);",
      "      await _metaBox.putAll(metaBatch);",
      "      return right(unit);",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, ${2:User}Dto>> getById(String id) async {",
      "    try {",
      "      final data = _${4:users}Box.get(id);",
      "      if (data == null) {",
      "        return left(const ${1:Domain}Failure.notFound('${3:User} not found in cache'));",
      "      }",
      "",
      "      final ${5:user}Dto = ${2:User}Dto.fromJson(Map<String, dynamic>.from(data));",
      "      return right(${5:user}Dto);",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, List<${2:User}Dto>>> getAll() async {",
      "    try {",
      "      final ${6:users} = <${2:User}Dto>[];",
      "",
      "      for (final data in _${4:users}Box.values) {",
      "        try {",
      "          final ${5:user}Dto = ${2:User}Dto.fromJson(Map<String, dynamic>.from(data));",
      "          ${6:users}.add(${5:user}Dto);",
      "        } catch (e) {",
      "          // Skip corrupted entries",
      "          continue;",
      "        }",
      "      }",
      "",
      "      return right(${6:users});",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, List<${2:User}Dto>>> getAllActive() async {",
      "    return search(filters: {'is_active': true});",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, List<${2:User}Dto>>> search({",
      "    String? query,",
      "    Map<String, dynamic>? filters,",
      "    String? sortBy,",
      "    bool ascending = true,",
      "    int? limit,",
      "    int? offset,",
      "  }) async {",
      "    try {",
      "      final allUsersResult = await getAll();",
      "      return allUsersResult.fold(",
      "        (failure) => left(failure),",
      "        (${6:users}) {",
      "          var filteredUsers = ${6:users};",
      "",
      "          // Apply text search",
      "          if (query != null && query.isNotEmpty) {",
      "            filteredUsers = filteredUsers.where((${5:user}) {",
      "              return ${5:user}.name.toLowerCase().contains(query.toLowerCase()) ||",
      "                  ${5:user}.email.toLowerCase().contains(query.toLowerCase());",
      "            }).toList();",
      "          }",
      "",
      "          // Apply filters",
      "          if (filters != null) {",
      "            filteredUsers = filteredUsers.where((${5:user}) {",
      "              return _matchesFilters(${5:user}, filters);",
      "            }).toList();",
      "          }",
      "",
      "          // Apply sorting",
      "          if (sortBy != null) {",
      "            filteredUsers.sort((a, b) {",
      "              final comparison = _compareByField(a, b, sortBy);",
      "              return ascending ? comparison : -comparison;",
      "            });",
      "          }",
      "",
      "          // Apply pagination",
      "          if (offset != null) {",
      "            if (offset >= filteredUsers.length) {",
      "              filteredUsers = [];",
      "            } else {",
      "              filteredUsers = filteredUsers.skip(offset).toList();",
      "            }",
      "          }",
      "",
      "          if (limit != null && limit > 0) {",
      "            filteredUsers = filteredUsers.take(limit).toList();",
      "          }",
      "",
      "          return right(filteredUsers);",
      "        },",
      "      );",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, ${2:User}Dto?>> findByEmail(String email) async {",
      "    return search(filters: {'email': email}).then((result) {",
      "      return result.fold(",
      "        (failure) => left(failure),",
      "        (${6:users}) => right(${6:users}.isNotEmpty ? ${6:users}.first : null),",
      "      );",
      "    });",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> delete(String id) async {",
      "    try {",
      "      await _${4:users}Box.delete(id);",
      "      await _metaBox.delete('\\${id}_cached_at');",
      "      await _syncBox.delete(id);",
      "      return right(unit);",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> deleteAll() async {",
      "    try {",
      "      await _${4:users}Box.clear();",
      "      await _metaBox.clear();",
      "      await _syncBox.clear();",
      "      return right(unit);",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> deleteMany(List<String> ids) async {",
      "    try {",
      "      await _${4:users}Box.deleteAll(ids);",
      "      final metaKeys = ids.map((id) => '\\${id}_cached_at').toList();",
      "      await _metaBox.deleteAll(metaKeys);",
      "      await _syncBox.deleteAll(ids);",
      "      return right(unit);",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<bool> exists(String id) async {",
      "    return _${4:users}Box.containsKey(id);",
      "  }",
      "",
      "  @override",
      "  Future<bool> existsByEmail(String email) async {",
      "    final result = await findByEmail(email);",
      "    return result.fold((_) => false, (${5:user}) => ${5:user} != null);",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> clearCache() async {",
      "    return deleteAll();",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> clearExpiredCache() async {",
      "    try {",
      "      final expiredKeys = <String>[];",
      "      final cutoffTime = DateTime.now().subtract(const Duration(hours: 24));",
      "",
      "      for (final key in _metaBox.keys) {",
      "        if (key.toString().endsWith('_cached_at')) {",
      "          final meta = _metaBox.get(key);",
      "          if (meta != null) {",
      "            final timestampStr = meta['timestamp'] as String?;",
      "            if (timestampStr != null) {",
      "              final cachedAt = DateTime.tryParse(timestampStr);",
      "              if (cachedAt != null && cachedAt.isBefore(cutoffTime)) {",
      "                final ${5:user}Id = key.toString().replaceAll('_cached_at', '');",
      "                expiredKeys.add(${5:user}Id);",
      "              }",
      "            }",
      "          }",
      "        }",
      "      }",
      "",
      "      await deleteMany(expiredKeys);",
      "      return right(unit);",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, int>> getCacheSize() async {",
      "    try {",
      "      return right(_${4:users}Box.length);",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, DateTime?>> getLastCacheUpdate(String id) async {",
      "    try {",
      "      final meta = _metaBox.get('\\${id}_cached_at');",
      "      if (meta == null) return right(null);",
      "",
      "      final timestampStr = meta['timestamp'] as String?;",
      "      if (timestampStr == null) return right(null);",
      "",
      "      return right(DateTime.tryParse(timestampStr));",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, int>> count([Map<String, dynamic>? filters]) async {",
      "    final result = await search(filters: filters);",
      "    return result.fold(",
      "      (failure) => left(failure),",
      "      (${6:users}) => right(${6:users}.length),",
      "    );",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Map<String, int>>> getCacheStatistics() async {",
      "    try {",
      "      final total = _${4:users}Box.length;",
      "      final active = await count({'is_active': true});",
      "",
      "      return active.fold(",
      "        (failure) => left(failure),",
      "        (activeCount) => right({",
      "          'total': total,",
      "          'active': activeCount,",
      "          'inactive': total - activeCount,",
      "        }),",
      "      );",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, List<${2:User}Dto>>> getPendingSync() async {",
      "    try {",
      "      final pendingUsers = <${2:User}Dto>[];",
      "",
      "      for (final id in _syncBox.keys) {",
      "        final ${5:user}Data = _${4:users}Box.get(id);",
      "        if (${5:user}Data != null) {",
      "          try {",
      "            final ${5:user}Dto = ${2:User}Dto.fromJson(Map<String, dynamic>.from(${5:user}Data));",
      "            pendingUsers.add(${5:user}Dto);",
      "          } catch (e) {",
      "            // Skip corrupted entries",
      "            continue;",
      "          }",
      "        }",
      "      }",
      "",
      "      return right(pendingUsers);",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> markAsSynced(String id) async {",
      "    try {",
      "      await _syncBox.delete(id);",
      "      return right(unit);",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> markForSync(${2:User}Dto ${5:user}Dto) async {",
      "    try {",
      "      await _syncBox.put(${5:user}Dto.id, {",
      "        'marked_at': DateTime.now().toIso8601String(),",
      "        'operation': 'update',",
      "      });",
      "      return right(unit);",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, String>> exportData() async {",
      "    try {",
      "      final allUsersResult = await getAll();",
      "      return allUsersResult.fold(",
      "        (failure) => left(failure),",
      "        (${6:users}) {",
      "          final exportData = {",
      "            'version': 1,",
      "            'exported_at': DateTime.now().toIso8601String(),",
      "            '${4:users}': ${6:users}.map((${5:user}) => ${5:user}.toJson()).toList(),",
      "          };",
      "          return right(jsonEncode(exportData));",
      "        },",
      "      );",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> importData(String data) async {",
      "    try {",
      "      final importData = jsonDecode(data) as Map<String, dynamic>;",
      "      final ${6:users}Data = importData['${4:users}'] as List<dynamic>;",
      "",
      "      final ${6:users} = ${6:users}Data",
      "          .map((${5:user}Data) => ${2:User}Dto.fromJson(${5:user}Data as Map<String, dynamic>))",
      "          .toList();",
      "",
      "      return await cacheAll(${6:users});",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.parsingError('Failed to import data: \\$e'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, Unit>> migrate(int fromVersion, int toVersion) async {",
      "    try {",
      "      // Implement migration logic based on version differences",
      "      // This is a placeholder implementation",
      "      return right(unit);",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<${1:Domain}Failure, int>> getCurrentVersion() async {",
      "    try {",
      "      final version = _metaBox.get('cache_version', defaultValue: {'version': 1});",
      "      return right(version!['version'] as int);",
      "    } catch (e) {",
      "      return left(${1:Domain}Failure.cacheError());",
      "    }",
      "  }",
      "",
      "  // Private helper methods",
      "  bool _matchesFilters(${2:User}Dto ${5:user}, Map<String, dynamic> filters) {",
      "    for (final entry in filters.entries) {",
      "      final key = entry.key;",
      "      final value = entry.value;",
      "",
      "      switch (key) {",
      "        case 'email':",
      "          if (${5:user}.email != value) return false;",
      "          break;",
      "        case 'is_active':",
      "          if (${5:user}.isActive != value) return false;",
      "          break;",
      "        case 'created_after':",
      "          final createdAt = ${5:user}.parsedCreatedAt;",
      "          final filterDate = DateTime.tryParse(value.toString());",
      "          if (createdAt == null || filterDate == null || createdAt.isBefore(filterDate)) {",
      "            return false;",
      "          }",
      "          break;",
      "        case 'created_before':",
      "          final createdAt = ${5:user}.parsedCreatedAt;",
      "          final filterDate = DateTime.tryParse(value.toString());",
      "          if (createdAt == null || filterDate == null || createdAt.isAfter(filterDate)) {",
      "            return false;",
      "          }",
      "          break;",
      "        // Add more filter conditions as needed",
      "      }",
      "    }",
      "    return true;",
      "  }",
      "",
      "  int _compareByField(${2:User}Dto a, ${2:User}Dto b, String field) {",
      "    switch (field) {",
      "      case 'name':",
      "        return a.name.compareTo(b.name);",
      "      case 'email':",
      "        return a.email.compareTo(b.email);",
      "      case 'created_at':",
      "        final aDate = a.parsedCreatedAt;",
      "        final bDate = b.parsedCreatedAt;",
      "        if (aDate == null && bDate == null) return 0;",
      "        if (aDate == null) return 1;",
      "        if (bDate == null) return -1;",
      "        return aDate.compareTo(bDate);",
      "      case 'updated_at':",
      "        final aDate = a.parsedUpdatedAt;",
      "        final bDate = b.parsedUpdatedAt;",
      "        if (aDate == null && bDate == null) return 0;",
      "        if (aDate == null) return 1;",
      "        if (bDate == null) return -1;",
      "        return aDate.compareTo(bDate);",
      "      default:",
      "        return 0;",
      "    }",
      "  }",
      "}",
      "$0"
    ]
  }
}
