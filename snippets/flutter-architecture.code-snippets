{
  "BLoC Pattern": {
    "prefix": "fla-bloc",
    "description": "Complete BLoC pattern implementation",
    "body": [
      "import 'package:flutter_bloc/flutter_bloc.dart';",
      "import 'package:equatable/equatable.dart';",
      "",
      "// Events",
      "abstract class ${1:Counter}Event extends Equatable {",
      "  const ${1:Counter}Event();",
      "",
      "  @override",
      "  List<Object> get props => [];",
      "}",
      "",
      "class ${1:Counter}Increment extends ${1:Counter}Event {}",
      "",
      "class ${1:Counter}Decrement extends ${1:Counter}Event {}",
      "",
      "class ${1:Counter}Reset extends ${1:Counter}Event {}",
      "",
      "// States",
      "abstract class ${1:Counter}State extends Equatable {",
      "  const ${1:Counter}State();",
      "",
      "  @override",
      "  List<Object> get props => [];",
      "}",
      "",
      "class ${1:Counter}Initial extends ${1:Counter}State {}",
      "",
      "class ${1:Counter}Loading extends ${1:Counter}State {}",
      "",
      "class ${1:Counter}Loaded extends ${1:Counter}State {",
      "  const ${1:Counter}Loaded({required this.count});",
      "",
      "  final int count;",
      "",
      "  @override",
      "  List<Object> get props => [count];",
      "}",
      "",
      "class ${1:Counter}Error extends ${1:Counter}State {",
      "  const ${1:Counter}Error({required this.message});",
      "",
      "  final String message;",
      "",
      "  @override",
      "  List<Object> get props => [message];",
      "}",
      "",
      "// BLoC",
      "class ${1:Counter}Bloc extends Bloc<${1:Counter}Event, ${1:Counter}State> {",
      "  ${1:Counter}Bloc() : super(const ${1:Counter}Loaded(count: 0)) {",
      "    on<${1:Counter}Increment>(_onIncrement);",
      "    on<${1:Counter}Decrement>(_onDecrement);",
      "    on<${1:Counter}Reset>(_onReset);",
      "  }",
      "",
      "  void _onIncrement(${1:Counter}Increment event, Emitter<${1:Counter}State> emit) {",
      "    if (state is ${1:Counter}Loaded) {",
      "      final currentState = state as ${1:Counter}Loaded;",
      "      emit(${1:Counter}Loaded(count: currentState.count + 1));",
      "    }",
      "  }",
      "",
      "  void _onDecrement(${1:Counter}Decrement event, Emitter<${1:Counter}State> emit) {",
      "    if (state is ${1:Counter}Loaded) {",
      "      final currentState = state as ${1:Counter}Loaded;",
      "      emit(${1:Counter}Loaded(count: currentState.count - 1));",
      "    }",
      "  }",
      "",
      "  void _onReset(${1:Counter}Reset event, Emitter<${1:Counter}State> emit) {",
      "    emit(const ${1:Counter}Loaded(count: 0));",
      "  }",
      "}$0"
    ]
  },

  "Cubit Pattern": {
    "prefix": "fla-cubit",
    "description": "Simple Cubit pattern implementation",
    "body": [
      "import 'package:flutter_bloc/flutter_bloc.dart';",
      "import 'package:equatable/equatable.dart';",
      "",
      "// State",
      "class ${1:Counter}State extends Equatable {",
      "  const ${1:Counter}State({",
      "    this.count = 0,",
      "    this.isLoading = false,",
      "    this.error,",
      "  });",
      "",
      "  final int count;",
      "  final bool isLoading;",
      "  final String? error;",
      "",
      "  ${1:Counter}State copyWith({",
      "    int? count,",
      "    bool? isLoading,",
      "    String? error,",
      "  }) {",
      "    return ${1:Counter}State(",
      "      count: count ?? this.count,",
      "      isLoading: isLoading ?? this.isLoading,",
      "      error: error ?? this.error,",
      "    );",
      "  }",
      "",
      "  @override",
      "  List<Object?> get props => [count, isLoading, error];",
      "}",
      "",
      "// Cubit",
      "class ${1:Counter}Cubit extends Cubit<${1:Counter}State> {",
      "  ${1:Counter}Cubit() : super(const ${1:Counter}State());",
      "",
      "  void increment() {",
      "    emit(state.copyWith(count: state.count + 1));",
      "  }",
      "",
      "  void decrement() {",
      "    emit(state.copyWith(count: state.count - 1));",
      "  }",
      "",
      "  void reset() {",
      "    emit(state.copyWith(count: 0));",
      "  }",
      "",
      "  Future<void> ${2:loadData}() async {",
      "    emit(state.copyWith(isLoading: true, error: null));",
      "    ",
      "    try {",
      "      ${3:// Simulate API call}",
      "      await Future.delayed(const Duration(seconds: 2));",
      "      ",
      "      ${4:// Update state with data}",
      "      emit(state.copyWith(isLoading: false));",
      "    } catch (e) {",
      "      emit(state.copyWith(",
      "        isLoading: false,",
      "        error: e.toString(),",
      "      ));",
      "    }",
      "  }",
      "}$0"
    ]
  },

  "Repository Pattern": {
    "prefix": "fla-repository",
    "description": "Repository pattern with local and remote data sources",
    "body": [
      "import 'package:dartz/dartz.dart';",
      "",
      "// Entities",
      "class ${1:User} {",
      "  const ${1:User}({",
      "    required this.id,",
      "    required this.name,",
      "    required this.email,",
      "  });",
      "",
      "  final String id;",
      "  final String name;",
      "  final String email;",
      "}",
      "",
      "// Failures",
      "abstract class Failure {",
      "  const Failure({required this.message});",
      "  final String message;",
      "}",
      "",
      "class ServerFailure extends Failure {",
      "  const ServerFailure({required super.message});",
      "}",
      "",
      "class CacheFailure extends Failure {",
      "  const CacheFailure({required super.message});",
      "}",
      "",
      "class NetworkFailure extends Failure {",
      "  const NetworkFailure({required super.message});",
      "}",
      "",
      "// Repository Interface",
      "abstract class ${1:User}Repository {",
      "  Future<Either<Failure, List<${1:User}>>> getUsers();",
      "  Future<Either<Failure, ${1:User}>> getUserById(String id);",
      "  Future<Either<Failure, ${1:User}>> createUser(${1:User} user);",
      "  Future<Either<Failure, ${1:User}>> updateUser(${1:User} user);",
      "  Future<Either<Failure, void>> deleteUser(String id);",
      "}",
      "",
      "// Data Sources",
      "abstract class ${1:User}RemoteDataSource {",
      "  Future<List<${1:User}>> getUsers();",
      "  Future<${1:User}> getUserById(String id);",
      "  Future<${1:User}> createUser(${1:User} user);",
      "  Future<${1:User}> updateUser(${1:User} user);",
      "  Future<void> deleteUser(String id);",
      "}",
      "",
      "abstract class ${1:User}LocalDataSource {",
      "  Future<List<${1:User}>> getUsers();",
      "  Future<${1:User}> getUserById(String id);",
      "  Future<void> cacheUsers(List<${1:User}> users);",
      "  Future<void> cacheUser(${1:User} user);",
      "  Future<void> deleteUser(String id);",
      "}",
      "",
      "// Repository Implementation",
      "class ${1:User}RepositoryImpl implements ${1:User}Repository {",
      "  const ${1:User}RepositoryImpl({",
      "    required this.remoteDataSource,",
      "    required this.localDataSource,",
      "    required this.networkInfo,",
      "  });",
      "",
      "  final ${1:User}RemoteDataSource remoteDataSource;",
      "  final ${1:User}LocalDataSource localDataSource;",
      "  final NetworkInfo networkInfo;",
      "",
      "  @override",
      "  Future<Either<Failure, List<${1:User}>>> getUsers() async {",
      "    if (await networkInfo.isConnected) {",
      "      try {",
      "        final remoteUsers = await remoteDataSource.getUsers();",
      "        localDataSource.cacheUsers(remoteUsers);",
      "        return Right(remoteUsers);",
      "      } catch (e) {",
      "        return Left(ServerFailure(message: e.toString()));",
      "      }",
      "    } else {",
      "      try {",
      "        final localUsers = await localDataSource.getUsers();",
      "        return Right(localUsers);",
      "      } catch (e) {",
      "        return Left(CacheFailure(message: e.toString()));",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<Failure, ${1:User}>> getUserById(String id) async {",
      "    if (await networkInfo.isConnected) {",
      "      try {",
      "        final user = await remoteDataSource.getUserById(id);",
      "        localDataSource.cacheUser(user);",
      "        return Right(user);",
      "      } catch (e) {",
      "        return Left(ServerFailure(message: e.toString()));",
      "      }",
      "    } else {",
      "      try {",
      "        final user = await localDataSource.getUserById(id);",
      "        return Right(user);",
      "      } catch (e) {",
      "        return Left(CacheFailure(message: e.toString()));",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<Failure, ${1:User}>> createUser(${1:User} user) async {",
      "    if (await networkInfo.isConnected) {",
      "      try {",
      "        final createdUser = await remoteDataSource.createUser(user);",
      "        localDataSource.cacheUser(createdUser);",
      "        return Right(createdUser);",
      "      } catch (e) {",
      "        return Left(ServerFailure(message: e.toString()));",
      "      }",
      "    } else {",
      "      return const Left(NetworkFailure(message: 'No internet connection'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<Failure, ${1:User}>> updateUser(${1:User} user) async {",
      "    if (await networkInfo.isConnected) {",
      "      try {",
      "        final updatedUser = await remoteDataSource.updateUser(user);",
      "        localDataSource.cacheUser(updatedUser);",
      "        return Right(updatedUser);",
      "      } catch (e) {",
      "        return Left(ServerFailure(message: e.toString()));",
      "      }",
      "    } else {",
      "      return const Left(NetworkFailure(message: 'No internet connection'));",
      "    }",
      "  }",
      "",
      "  @override",
      "  Future<Either<Failure, void>> deleteUser(String id) async {",
      "    if (await networkInfo.isConnected) {",
      "      try {",
      "        await remoteDataSource.deleteUser(id);",
      "        await localDataSource.deleteUser(id);",
      "        return const Right(null);",
      "      } catch (e) {",
      "        return Left(ServerFailure(message: e.toString()));",
      "      }",
      "    } else {",
      "      return const Left(NetworkFailure(message: 'No internet connection'));",
      "    }",
      "  }",
      "}",
      "",
      "// Network Info",
      "abstract class NetworkInfo {",
      "  Future<bool> get isConnected;",
      "}$0"
    ]
  },

  "Use Case": {
    "prefix": "fla-usecase",
    "description": "Use case pattern implementation",
    "body": [
      "import 'package:dartz/dartz.dart';",
      "import 'package:equatable/equatable.dart';",
      "",
      "abstract class UseCase<Type, Params> {",
      "  Future<Either<Failure, Type>> call(Params params);",
      "}",
      "",
      "class NoParams extends Equatable {",
      "  @override",
      "  List<Object> get props => [];",
      "}",
      "",
      "class ${1:GetUser}Params extends Equatable {",
      "  const ${1:GetUser}Params({required this.id});",
      "",
      "  final String id;",
      "",
      "  @override",
      "  List<Object> get props => [id];",
      "}",
      "",
      "class ${1:GetUser} implements UseCase<${2:User}, ${1:GetUser}Params> {",
      "  const ${1:GetUser}(this.repository);",
      "",
      "  final ${2:User}Repository repository;",
      "",
      "  @override",
      "  Future<Either<Failure, ${2:User}>> call(${1:GetUser}Params params) async {",
      "    return await repository.getUserById(params.id);",
      "  }",
      "}",
      "",
      "class ${3:GetUsers} implements UseCase<List<${2:User}>, NoParams> {",
      "  const ${3:GetUsers}(this.repository);",
      "",
      "  final ${2:User}Repository repository;",
      "",
      "  @override",
      "  Future<Either<Failure, List<${2:User}>>> call(NoParams params) async {",
      "    return await repository.getUsers();",
      "  }",
      "}$0"
    ]
  },

  "Provider Pattern": {
    "prefix": "fla-provider",
    "description": "Provider pattern with ChangeNotifier",
    "body": [
      "import 'package:flutter/foundation.dart';",
      "",
      "class ${1:Counter}Provider extends ChangeNotifier {",
      "  int _count = 0;",
      "  bool _isLoading = false;",
      "  String? _error;",
      "",
      "  int get count => _count;",
      "  bool get isLoading => _isLoading;",
      "  String? get error => _error;",
      "",
      "  void increment() {",
      "    _count++;",
      "    notifyListeners();",
      "  }",
      "",
      "  void decrement() {",
      "    _count--;",
      "    notifyListeners();",
      "  }",
      "",
      "  void reset() {",
      "    _count = 0;",
      "    notifyListeners();",
      "  }",
      "",
      "  Future<void> ${2:loadData}() async {",
      "    _setLoading(true);",
      "    _setError(null);",
      "    ",
      "    try {",
      "      ${3:// Simulate API call}",
      "      await Future.delayed(const Duration(seconds: 2));",
      "      ",
      "      ${4:// Update data}",
      "      _count = 42;",
      "      _setLoading(false);",
      "    } catch (e) {",
      "      _setError(e.toString());",
      "      _setLoading(false);",
      "    }",
      "  }",
      "",
      "  void _setLoading(bool loading) {",
      "    _isLoading = loading;",
      "    notifyListeners();",
      "  }",
      "",
      "  void _setError(String? error) {",
      "    _error = error;",
      "    notifyListeners();",
      "  }",
      "}$0"
    ]
  },

  "Service Locator": {
    "prefix": "fla-getit",
    "description": "GetIt service locator setup",
    "body": [
      "import 'package:get_it/get_it.dart';",
      "import 'package:dio/dio.dart';",
      "import 'package:shared_preferences/shared_preferences.dart';",
      "",
      "final GetIt sl = GetIt.instance;",
      "",
      "Future<void> ${1:initializeDependencies}() async {",
      "  // External",
      "  final sharedPreferences = await SharedPreferences.getInstance();",
      "  sl.registerLazySingleton(() => sharedPreferences);",
      "  sl.registerLazySingleton(() => Dio());",
      "",
      "  // Core",
      "  sl.registerLazySingleton<NetworkInfo>(() => NetworkInfoImpl(sl()));",
      "",
      "  // Data sources",
      "  sl.registerLazySingleton<${2:User}RemoteDataSource>(",
      "    () => ${2:User}RemoteDataSourceImpl(client: sl()),",
      "  );",
      "  sl.registerLazySingleton<${2:User}LocalDataSource>(",
      "    () => ${2:User}LocalDataSourceImpl(sharedPreferences: sl()),",
      "  );",
      "",
      "  // Repository",
      "  sl.registerLazySingleton<${2:User}Repository>(",
      "    () => ${2:User}RepositoryImpl(",
      "      remoteDataSource: sl(),",
      "      localDataSource: sl(),",
      "      networkInfo: sl(),",
      "    ),",
      "  );",
      "",
      "  // Use cases",
      "  sl.registerLazySingleton(() => ${3:GetUsers}(sl()));",
      "  sl.registerLazySingleton(() => ${4:GetUser}(sl()));",
      "  sl.registerLazySingleton(() => ${5:CreateUser}(sl()));",
      "  sl.registerLazySingleton(() => ${6:UpdateUser}(sl()));",
      "  sl.registerLazySingleton(() => ${7:DeleteUser}(sl()));",
      "",
      "  // BLoC",
      "  sl.registerFactory(",
      "    () => ${2:User}Bloc(",
      "      getUsers: sl(),",
      "      getUser: sl(),",
      "      createUser: sl(),",
      "      updateUser: sl(),",
      "      deleteUser: sl(),",
      "    ),",
      "  );",
      "}$0"
    ]
  },

  "API Client": {
    "prefix": "fla-api",
    "description": "Dio API client with interceptors",
    "body": [
      "import 'package:dio/dio.dart';",
      "import 'package:pretty_dio_logger/pretty_dio_logger.dart';",
      "",
      "class ${1:ApiClient} {",
      "  late final Dio _dio;",
      "",
      "  ${1:ApiClient}({",
      "    required String baseUrl,",
      "    String? token,",
      "  }) {",
      "    _dio = Dio(",
      "      BaseOptions(",
      "        baseUrl: baseUrl,",
      "        connectTimeout: const Duration(seconds: 30),",
      "        receiveTimeout: const Duration(seconds: 30),",
      "        headers: {",
      "          'Content-Type': 'application/json',",
      "          'Accept': 'application/json',",
      "          if (token != null) 'Authorization': 'Bearer \\$token',",
      "        },",
      "      ),",
      "    );",
      "",
      "    _dio.interceptors.addAll([",
      "      PrettyDioLogger(",
      "        requestHeader: true,",
      "        requestBody: true,",
      "        responseBody: true,",
      "        responseHeader: false,",
      "        error: true,",
      "        compact: true,",
      "      ),",
      "      InterceptorsWrapper(",
      "        onRequest: (options, handler) {",
      "          ${2:// Add request interceptor logic}",
      "          handler.next(options);",
      "        },",
      "        onResponse: (response, handler) {",
      "          ${3:// Add response interceptor logic}",
      "          handler.next(response);",
      "        },",
      "        onError: (error, handler) {",
      "          ${4:// Add error interceptor logic}",
      "          handler.next(error);",
      "        },",
      "      ),",
      "    ]);",
      "  }",
      "",
      "  Future<Response<T>> get<T>(",
      "    String path, {",
      "    Map<String, dynamic>? queryParameters,",
      "    Options? options,",
      "  }) async {",
      "    try {",
      "      return await _dio.get<T>(",
      "        path,",
      "        queryParameters: queryParameters,",
      "        options: options,",
      "      );",
      "    } on DioException catch (e) {",
      "      throw _handleError(e);",
      "    }",
      "  }",
      "",
      "  Future<Response<T>> post<T>(",
      "    String path, {",
      "    dynamic data,",
      "    Map<String, dynamic>? queryParameters,",
      "    Options? options,",
      "  }) async {",
      "    try {",
      "      return await _dio.post<T>(",
      "        path,",
      "        data: data,",
      "        queryParameters: queryParameters,",
      "        options: options,",
      "      );",
      "    } on DioException catch (e) {",
      "      throw _handleError(e);",
      "    }",
      "  }",
      "",
      "  Future<Response<T>> put<T>(",
      "    String path, {",
      "    dynamic data,",
      "    Map<String, dynamic>? queryParameters,",
      "    Options? options,",
      "  }) async {",
      "    try {",
      "      return await _dio.put<T>(",
      "        path,",
      "        data: data,",
      "        queryParameters: queryParameters,",
      "        options: options,",
      "      );",
      "    } on DioException catch (e) {",
      "      throw _handleError(e);",
      "    }",
      "  }",
      "",
      "  Future<Response<T>> delete<T>(",
      "    String path, {",
      "    dynamic data,",
      "    Map<String, dynamic>? queryParameters,",
      "    Options? options,",
      "  }) async {",
      "    try {",
      "      return await _dio.delete<T>(",
      "        path,",
      "        data: data,",
      "        queryParameters: queryParameters,",
      "        options: options,",
      "      );",
      "    } on DioException catch (e) {",
      "      throw _handleError(e);",
      "    }",
      "  }",
      "",
      "  Exception _handleError(DioException error) {",
      "    switch (error.type) {",
      "      case DioExceptionType.connectionTimeout:",
      "      case DioExceptionType.sendTimeout:",
      "      case DioExceptionType.receiveTimeout:",
      "        return TimeoutException('Connection timeout');",
      "      case DioExceptionType.badResponse:",
      "        return ServerException(",
      "          'Server error: \\${error.response?.statusCode}',",
      "        );",
      "      case DioExceptionType.cancel:",
      "        return CancelException('Request cancelled');",
      "      case DioExceptionType.connectionError:",
      "        return NetworkException('Network connection error');",
      "      default:",
      "        return GeneralException('Unknown error occurred');",
      "    }",
      "  }",
      "}",
      "",
      "// Custom Exceptions",
      "class TimeoutException implements Exception {",
      "  final String message;",
      "  TimeoutException(this.message);",
      "}",
      "",
      "class ServerException implements Exception {",
      "  final String message;",
      "  ServerException(this.message);",
      "}",
      "",
      "class NetworkException implements Exception {",
      "  final String message;",
      "  NetworkException(this.message);",
      "}",
      "",
      "class CancelException implements Exception {",
      "  final String message;",
      "  CancelException(this.message);",
      "}",
      "",
      "class GeneralException implements Exception {",
      "  final String message;",
      "  GeneralException(this.message);",
      "}$0"
    ]
  }
}
