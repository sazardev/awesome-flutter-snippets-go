{
  "GraphQL Client": {
    "prefix": "fln-graphql-client",
    "description": "Complete GraphQL client with caching and error handling",
    "body": [
      "import 'package:graphql_flutter/graphql_flutter.dart';",
      "import 'package:flutter/material.dart';",
      "",
      "class ${1:GraphQL}Client {",
      "  static late GraphQLClient _client;",
      "  static final ValueNotifier<GraphQLClient> _clientNotifier =",
      "      ValueNotifier<GraphQLClient>(_createClient());",
      "",
      "  static GraphQLClient _createClient() {",
      "    final HttpLink httpLink = HttpLink(",
      "      '${2:https://api.example.com/graphql}',",
      "      defaultHeaders: {",
      "        'Content-Type': 'application/json',",
      "        'Accept': 'application/json',",
      "      },",
      "    );",
      "",
      "    final AuthLink authLink = AuthLink(",
      "      getToken: () async {",
      "        // Get token from secure storage",
      "        return 'Bearer your_token_here';",
      "      },",
      "    );",
      "",
      "    final Link link = authLink.concat(httpLink);",
      "",
      "    return GraphQLClient(",
      "      link: link,",
      "      cache: GraphQLCache(",
      "        store: HiveStore(),",
      "      ),",
      "      defaultPolicies: DefaultPolicies(",
      "        watchQuery: Policies(",
      "          fetch: FetchPolicy.cacheAndNetwork,",
      "          error: ErrorPolicy.all,",
      "          cacheReread: CacheRereadPolicy.mergeOptimistic,",
      "        ),",
      "        query: Policies(",
      "          fetch: FetchPolicy.cacheFirst,",
      "          error: ErrorPolicy.all,",
      "        ),",
      "        mutate: Policies(",
      "          fetch: FetchPolicy.networkOnly,",
      "          error: ErrorPolicy.all,",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  static ValueNotifier<GraphQLClient> get client => _clientNotifier;",
      "",
      "  static void updateToken(String? token) {",
      "    _clientNotifier.value = _createClient();",
      "  }",
      "}",
      "",
      "// GraphQL Queries",
      "class ${3:User}Queries {",
      "  static const String getUsers = '''",
      "    query GetUsers(\\$limit: Int, \\$offset: Int) {",
      "      users(limit: \\$limit, offset: \\$offset) {",
      "        id",
      "        name",
      "        email",
      "        avatar",
      "        createdAt",
      "      }",
      "    }",
      "  ''';",
      "",
      "  static const String getUserById = '''",
      "    query GetUserById(\\$id: ID!) {",
      "      user(id: \\$id) {",
      "        id",
      "        name",
      "        email",
      "        avatar",
      "        bio",
      "        createdAt",
      "        updatedAt",
      "      }",
      "    }",
      "  ''';",
      "",
      "  static const String createUser = '''",
      "    mutation CreateUser(\\$input: CreateUserInput!) {",
      "      createUser(input: \\$input) {",
      "        id",
      "        name",
      "        email",
      "        avatar",
      "      }",
      "    }",
      "  ''';",
      "",
      "  static const String updateUser = '''",
      "    mutation UpdateUser(\\$id: ID!, \\$input: UpdateUserInput!) {",
      "      updateUser(id: \\$id, input: \\$input) {",
      "        id",
      "        name",
      "        email",
      "        avatar",
      "        updatedAt",
      "      }",
      "    }",
      "  ''';",
      "}",
      "",
      "// GraphQL Widget",
      "class ${4:Users}Query extends StatelessWidget {",
      "  const ${4:Users}Query({",
      "    super.key,",
      "    this.limit = 10,",
      "    this.offset = 0,",
      "  });",
      "",
      "  final int limit;",
      "  final int offset;",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return GraphQLProvider(",
      "      client: ${1:GraphQL}Client.client,",
      "      child: Query(",
      "        options: QueryOptions(",
      "          document: gql(${3:User}Queries.getUsers),",
      "          variables: {",
      "            'limit': limit,",
      "            'offset': offset,",
      "          },",
      "          pollInterval: const Duration(seconds: 30),",
      "          errorPolicy: ErrorPolicy.all,",
      "        ),",
      "        builder: (QueryResult result, {VoidCallback? refetch, FetchMore? fetchMore}) {",
      "          if (result.hasException) {",
      "            return Center(",
      "              child: Column(",
      "                mainAxisAlignment: MainAxisAlignment.center,",
      "                children: [",
      "                  Icon(",
      "                    Icons.error_outline,",
      "                    size: 64,",
      "                    color: Theme.of(context).colorScheme.error,",
      "                  ),",
      "                  const SizedBox(height: 16),",
      "                  Text(",
      "                    result.exception?.toString() ?? 'An error occurred',",
      "                    textAlign: TextAlign.center,",
      "                    style: TextStyle(",
      "                      color: Theme.of(context).colorScheme.error,",
      "                    ),",
      "                  ),",
      "                  const SizedBox(height: 16),",
      "                  ElevatedButton(",
      "                    onPressed: refetch,",
      "                    child: const Text('Retry'),",
      "                  ),",
      "                ],",
      "              ),",
      "            );",
      "          }",
      "",
      "          if (result.isLoading && result.data == null) {",
      "            return const Center(",
      "              child: CircularProgressIndicator(),",
      "            );",
      "          }",
      "",
      "          final users = result.data?['users'] as List<dynamic>? ?? [];",
      "",
      "          return RefreshIndicator(",
      "            onRefresh: () async {",
      "              refetch?.call();",
      "            },",
      "            child: ListView.builder(",
      "              itemCount: users.length,",
      "              itemBuilder: (context, index) {",
      "                final user = users[index] as Map<String, dynamic>;",
      "                return ListTile(",
      "                  leading: CircleAvatar(",
      "                    backgroundImage: NetworkImage(",
      "                      user['avatar'] ?? '',",
      "                    ),",
      "                  ),",
      "                  title: Text(user['name'] ?? ''),",
      "                  subtitle: Text(user['email'] ?? ''),",
      "                  onTap: () {",
      "                    // Navigate to user details",
      "                  },",
      "                );",
      "              },",
      "            ),",
      "          );",
      "        },",
      "      ),",
      "    );",
      "  }",
      "}",
      "$0"
    ]
  },

  "WebSocket Manager": {
    "prefix": "fln-websocket",
    "description": "WebSocket manager with reconnection and message handling",
    "body": [
      "import 'dart:async';",
      "import 'dart:convert';",
      "import 'dart:io';",
      "import 'package:flutter/foundation.dart';",
      "",
      "class ${1:WebSocket}Manager {",
      "  static ${1:WebSocket}Manager? _instance;",
      "  static ${1:WebSocket}Manager get instance {",
      "    _instance ??= ${1:WebSocket}Manager._();",
      "    return _instance!;",
      "  }",
      "",
      "  ${1:WebSocket}Manager._();",
      "",
      "  WebSocket? _socket;",
      "  Timer? _heartbeatTimer;",
      "  Timer? _reconnectTimer;",
      "  bool _isReconnecting = false;",
      "  int _reconnectAttempts = 0;",
      "  static const int _maxReconnectAttempts = 5;",
      "  static const Duration _heartbeatInterval = Duration(seconds: 30);",
      "  static const Duration _reconnectDelay = Duration(seconds: 5);",
      "",
      "  // Event streams",
      "  final StreamController<Map<String, dynamic>> _messageController =",
      "      StreamController<Map<String, dynamic>>.broadcast();",
      "  final StreamController<bool> _connectionController =",
      "      StreamController<bool>.broadcast();",
      "",
      "  // Public streams",
      "  Stream<Map<String, dynamic>> get messageStream => _messageController.stream;",
      "  Stream<bool> get connectionStream => _connectionController.stream;",
      "",
      "  bool get isConnected => _socket != null;",
      "",
      "  Future<void> connect(String url, {Map<String, String>? headers}) async {",
      "    try {",
      "      if (_socket != null) {",
      "        await disconnect();",
      "      }",
      "",
      "      _socket = await WebSocket.connect(",
      "        url,",
      "        headers: headers,",
      "      );",
      "",
      "      _connectionController.add(true);",
      "      _reconnectAttempts = 0;",
      "",
      "      // Listen for messages",
      "      _socket!.listen(",
      "        _onMessage,",
      "        onError: _onError,",
      "        onDone: _onDisconnected,",
      "        cancelOnError: false,",
      "      );",
      "",
      "      // Start heartbeat",
      "      _startHeartbeat();",
      "",
      "      debugPrint('WebSocket connected to \\$url');",
      "    } catch (e) {",
      "      debugPrint('WebSocket connection failed: \\$e');",
      "      _connectionController.add(false);",
      "      _scheduleReconnect(url, headers: headers);",
      "    }",
      "  }",
      "",
      "  void _onMessage(dynamic data) {",
      "    try {",
      "      final message = jsonDecode(data.toString()) as Map<String, dynamic>;",
      "      ",
      "      // Handle special message types",
      "      if (message['type'] == 'pong') {",
      "        return; // Heartbeat response",
      "      }",
      "",
      "      _messageController.add(message);",
      "    } catch (e) {",
      "      debugPrint('Error parsing WebSocket message: \\$e');",
      "    }",
      "  }",
      "",
      "  void _onError(dynamic error) {",
      "    debugPrint('WebSocket error: \\$error');",
      "    _connectionController.add(false);",
      "  }",
      "",
      "  void _onDisconnected() {",
      "    debugPrint('WebSocket disconnected');",
      "    _socket = null;",
      "    _connectionController.add(false);",
      "    _stopHeartbeat();",
      "    ",
      "    if (!_isReconnecting) {",
      "      _scheduleReconnect();",
      "    }",
      "  }",
      "",
      "  void _scheduleReconnect([String? url, Map<String, String>? headers]) {",
      "    if (_reconnectAttempts >= _maxReconnectAttempts) {",
      "      debugPrint('Max reconnection attempts reached');",
      "      return;",
      "    }",
      "",
      "    _isReconnecting = true;",
      "    _reconnectAttempts++;",
      "",
      "    _reconnectTimer = Timer(_reconnectDelay, () {",
      "      if (url != null) {",
      "        connect(url, headers: headers);",
      "      }",
      "      _isReconnecting = false;",
      "    });",
      "  }",
      "",
      "  void _startHeartbeat() {",
      "    _heartbeatTimer = Timer.periodic(_heartbeatInterval, (timer) {",
      "      if (_socket != null) {",
      "        sendMessage({'type': 'ping'});",
      "      }",
      "    });",
      "  }",
      "",
      "  void _stopHeartbeat() {",
      "    _heartbeatTimer?.cancel();",
      "    _heartbeatTimer = null;",
      "  }",
      "",
      "  void sendMessage(Map<String, dynamic> message) {",
      "    if (_socket != null) {",
      "      try {",
      "        final jsonString = jsonEncode(message);",
      "        _socket!.add(jsonString);",
      "      } catch (e) {",
      "        debugPrint('Error sending WebSocket message: \\$e');",
      "      }",
      "    } else {",
      "      debugPrint('Cannot send message: WebSocket not connected');",
      "    }",
      "  }",
      "",
      "  Future<void> disconnect() async {",
      "    _reconnectTimer?.cancel();",
      "    _stopHeartbeat();",
      "    ",
      "    if (_socket != null) {",
      "      await _socket!.close();",
      "      _socket = null;",
      "    }",
      "    ",
      "    _connectionController.add(false);",
      "    debugPrint('WebSocket disconnected manually');",
      "  }",
      "",
      "  void dispose() {",
      "    disconnect();",
      "    _messageController.close();",
      "    _connectionController.close();",
      "  }",
      "}",
      "$0"
    ]
  }
}
