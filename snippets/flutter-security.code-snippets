{
  "Firebase Auth Setup": {
    "prefix": "fls-firebase-auth",
    "description": "Complete Firebase Authentication setup with error handling",
    "body": [
      "import 'package:firebase_auth/firebase_auth.dart';",
      "import 'package:google_sign_in/google_sign_in.dart';",
      "import 'package:flutter/services.dart';",
      "",
      "class ${1:Auth}Service {",
      "  static final FirebaseAuth _auth = FirebaseAuth.instance;",
      "  static final GoogleSignIn _googleSignIn = GoogleSignIn();",
      "",
      "  // Current user stream",
      "  static Stream<User?> get authStateChanges => _auth.authStateChanges();",
      "  static User? get currentUser => _auth.currentUser;",
      "",
      "  // Email & Password Authentication",
      "  static Future<AuthResult> signInWithEmail({",
      "    required String email,",
      "    required String password,",
      "  }) async {",
      "    try {",
      "      final credential = await _auth.signInWithEmailAndPassword(",
      "        email: email,",
      "        password: password,",
      "      );",
      "      return AuthResult.success(user: credential.user);",
      "    } on FirebaseAuthException catch (e) {",
      "      return AuthResult.failure(error: _handleAuthError(e));",
      "    } catch (e) {",
      "      return AuthResult.failure(error: 'An unexpected error occurred');",
      "    }",
      "  }",
      "",
      "  static Future<AuthResult> registerWithEmail({",
      "    required String email,",
      "    required String password,",
      "    String? displayName,",
      "  }) async {",
      "    try {",
      "      final credential = await _auth.createUserWithEmailAndPassword(",
      "        email: email,",
      "        password: password,",
      "      );",
      "      ",
      "      if (displayName != null && credential.user != null) {",
      "        await credential.user!.updateDisplayName(displayName);",
      "      }",
      "      ",
      "      return AuthResult.success(user: credential.user);",
      "    } on FirebaseAuthException catch (e) {",
      "      return AuthResult.failure(error: _handleAuthError(e));",
      "    } catch (e) {",
      "      return AuthResult.failure(error: 'An unexpected error occurred');",
      "    }",
      "  }",
      "",
      "  // Google Sign In",
      "  static Future<AuthResult> signInWithGoogle() async {",
      "    try {",
      "      final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();",
      "      if (googleUser == null) {",
      "        return AuthResult.failure(error: 'Google sign in was cancelled');",
      "      }",
      "",
      "      final GoogleSignInAuthentication googleAuth = await googleUser.authentication;",
      "      final credential = GoogleAuthProvider.credential(",
      "        accessToken: googleAuth.accessToken,",
      "        idToken: googleAuth.idToken,",
      "      );",
      "",
      "      final userCredential = await _auth.signInWithCredential(credential);",
      "      return AuthResult.success(user: userCredential.user);",
      "    } on FirebaseAuthException catch (e) {",
      "      return AuthResult.failure(error: _handleAuthError(e));",
      "    } on PlatformException catch (e) {",
      "      return AuthResult.failure(error: 'Platform error: \\${e.message}');",
      "    } catch (e) {",
      "      return AuthResult.failure(error: 'An unexpected error occurred');",
      "    }",
      "  }",
      "",
      "  // Password Reset",
      "  static Future<AuthResult> resetPassword(String email) async {",
      "    try {",
      "      await _auth.sendPasswordResetEmail(email: email);",
      "      return AuthResult.success();",
      "    } on FirebaseAuthException catch (e) {",
      "      return AuthResult.failure(error: _handleAuthError(e));",
      "    } catch (e) {",
      "      return AuthResult.failure(error: 'An unexpected error occurred');",
      "    }",
      "  }",
      "",
      "  // Sign Out",
      "  static Future<void> signOut() async {",
      "    await Future.wait([",
      "      _auth.signOut(),",
      "      _googleSignIn.signOut(),",
      "    ]);",
      "  }",
      "",
      "  // Delete Account",
      "  static Future<AuthResult> deleteAccount() async {",
      "    try {",
      "      final user = _auth.currentUser;",
      "      if (user != null) {",
      "        await user.delete();",
      "        return AuthResult.success();",
      "      }",
      "      return AuthResult.failure(error: 'No user signed in');",
      "    } on FirebaseAuthException catch (e) {",
      "      return AuthResult.failure(error: _handleAuthError(e));",
      "    } catch (e) {",
      "      return AuthResult.failure(error: 'An unexpected error occurred');",
      "    }",
      "  }",
      "",
      "  // Error handling",
      "  static String _handleAuthError(FirebaseAuthException e) {",
      "    switch (e.code) {",
      "      case 'user-not-found':",
      "        return 'No user found with this email address.';",
      "      case 'wrong-password':",
      "        return 'Wrong password provided.';",
      "      case 'email-already-in-use':",
      "        return 'An account already exists with this email.';",
      "      case 'weak-password':",
      "        return 'The password provided is too weak.';",
      "      case 'invalid-email':",
      "        return 'The email address is not valid.';",
      "      case 'user-disabled':",
      "        return 'This user account has been disabled.';",
      "      case 'too-many-requests':",
      "        return 'Too many requests. Try again later.';",
      "      case 'operation-not-allowed':",
      "        return 'This operation is not allowed.';",
      "      default:",
      "        return e.message ?? 'An unknown error occurred.';",
      "    }",
      "  }",
      "}",
      "",
      "// Result wrapper",
      "class AuthResult {",
      "  final bool isSuccess;",
      "  final User? user;",
      "  final String? error;",
      "",
      "  const AuthResult._({",
      "    required this.isSuccess,",
      "    this.user,",
      "    this.error,",
      "  });",
      "",
      "  factory AuthResult.success({User? user}) {",
      "    return AuthResult._(isSuccess: true, user: user);",
      "  }",
      "",
      "  factory AuthResult.failure({required String error}) {",
      "    return AuthResult._(isSuccess: false, error: error);",
      "  }",
      "}",
      "$0"
    ]
  },

  "Secure Storage": {
    "prefix": "fls-secure-storage",
    "description": "Secure storage wrapper with encryption",
    "body": [
      "import 'package:flutter_secure_storage/flutter_secure_storage.dart';",
      "import 'dart:convert';",
      "",
      "class ${1:Secure}Storage {",
      "  static const _storage = FlutterSecureStorage(",
      "    aOptions: AndroidOptions(",
      "      encryptedSharedPreferences: true,",
      "    ),",
      "    iOptions: IOSOptions(",
      "      accessibility: IOSAccessibility.first_unlock_this_device,",
      "    ),",
      "  );",
      "",
      "  // Keys",
      "  static const String _userTokenKey = 'user_token';",
      "  static const String _refreshTokenKey = 'refresh_token';",
      "  static const String _userDataKey = 'user_data';",
      "",
      "  // Token management",
      "  static Future<void> saveTokens({",
      "    required String accessToken,",
      "    required String refreshToken,",
      "  }) async {",
      "    await Future.wait([",
      "      _storage.write(key: _userTokenKey, value: accessToken),",
      "      _storage.write(key: _refreshTokenKey, value: refreshToken),",
      "    ]);",
      "  }",
      "",
      "  static Future<String?> getAccessToken() async {",
      "    return await _storage.read(key: _userTokenKey);",
      "  }",
      "",
      "  static Future<String?> getRefreshToken() async {",
      "    return await _storage.read(key: _refreshTokenKey);",
      "  }",
      "",
      "  static Future<void> clearTokens() async {",
      "    await Future.wait([",
      "      _storage.delete(key: _userTokenKey),",
      "      _storage.delete(key: _refreshTokenKey),",
      "    ]);",
      "  }",
      "",
      "  // User data",
      "  static Future<void> saveUserData(Map<String, dynamic> userData) async {",
      "    final jsonString = jsonEncode(userData);",
      "    await _storage.write(key: _userDataKey, value: jsonString);",
      "  }",
      "",
      "  static Future<Map<String, dynamic>?> getUserData() async {",
      "    final jsonString = await _storage.read(key: _userDataKey);",
      "    if (jsonString != null) {",
      "      return jsonDecode(jsonString) as Map<String, dynamic>;",
      "    }",
      "    return null;",
      "  }",
      "",
      "  static Future<void> clearUserData() async {",
      "    await _storage.delete(key: _userDataKey);",
      "  }",
      "",
      "  // Generic secure storage",
      "  static Future<void> saveSecure(String key, String value) async {",
      "    await _storage.write(key: key, value: value);",
      "  }",
      "",
      "  static Future<String?> getSecure(String key) async {",
      "    return await _storage.read(key: key);",
      "  }",
      "",
      "  static Future<void> deleteSecure(String key) async {",
      "    await _storage.delete(key: key);",
      "  }",
      "",
      "  // Clear all data",
      "  static Future<void> clearAll() async {",
      "    await _storage.deleteAll();",
      "  }",
      "",
      "  // Check if user is logged in",
      "  static Future<bool> isLoggedIn() async {",
      "    final token = await getAccessToken();",
      "    return token != null && token.isNotEmpty;",
      "  }",
      "}",
      "$0"
    ]
  },

  "Biometric Authentication": {
    "prefix": "fls-biometric-auth",
    "description": "Biometric authentication with local_auth",
    "body": [
      "import 'package:local_auth/local_auth.dart';",
      "import 'package:flutter/services.dart';",
      "",
      "class ${1:Biometric}Auth {",
      "  static final LocalAuthentication _localAuth = LocalAuthentication();",
      "",
      "  static Future<BiometricResult> checkBiometricSupport() async {",
      "    try {",
      "      final bool isAvailable = await _localAuth.isDeviceSupported();",
      "      if (!isAvailable) {",
      "        return BiometricResult.failure('Device does not support biometric authentication');",
      "      }",
      "",
      "      final bool canCheckBiometrics = await _localAuth.canCheckBiometrics;",
      "      if (!canCheckBiometrics) {",
      "        return BiometricResult.failure('Biometric authentication is not available');",
      "      }",
      "",
      "      final List<BiometricType> availableBiometrics =",
      "          await _localAuth.getAvailableBiometrics();",
      "",
      "      if (availableBiometrics.isEmpty) {",
      "        return BiometricResult.failure('No biometric methods enrolled');",
      "      }",
      "",
      "      return BiometricResult.success(",
      "        availableBiometrics: availableBiometrics,",
      "      );",
      "    } on PlatformException catch (e) {",
      "      return BiometricResult.failure('Platform error: \\${e.message}');",
      "    } catch (e) {",
      "      return BiometricResult.failure('Unknown error: \\$e');",
      "    }",
      "  }",
      "",
      "  static Future<BiometricResult> authenticate({",
      "    String localizedReason = 'Please authenticate to access the app',",
      "    bool biometricOnly = false,",
      "  }) async {",
      "    try {",
      "      // Check support first",
      "      final supportResult = await checkBiometricSupport();",
      "      if (!supportResult.isSuccess) {",
      "        return supportResult;",
      "      }",
      "",
      "      final bool didAuthenticate = await _localAuth.authenticate(",
      "        localizedReason: localizedReason,",
      "        options: AuthenticationOptions(",
      "          biometricOnly: biometricOnly,",
      "          stickyAuth: true,",
      "        ),",
      "      );",
      "",
      "      if (didAuthenticate) {",
      "        return BiometricResult.success();",
      "      } else {",
      "        return BiometricResult.failure('Authentication failed or was cancelled');",
      "      }",
      "    } on PlatformException catch (e) {",
      "      return BiometricResult.failure(_handlePlatformException(e));",
      "    } catch (e) {",
      "      return BiometricResult.failure('Unknown error: \\$e');",
      "    }",
      "  }",
      "",
      "  static String _handlePlatformException(PlatformException e) {",
      "    switch (e.code) {",
      "      case 'NotAvailable':",
      "        return 'Biometric authentication is not available';",
      "      case 'NotEnrolled':",
      "        return 'No biometric credentials are enrolled';",
      "      case 'LockedOut':",
      "        return 'Too many failed attempts. Try again later';",
      "      case 'PermanentlyLockedOut':",
      "        return 'Biometric authentication is permanently locked out';",
      "      case 'BiometricOnlyNotSupported':",
      "        return 'Biometric-only authentication is not supported';",
      "      default:",
      "        return e.message ?? 'Unknown platform error';",
      "    }",
      "  }",
      "}",
      "",
      "class BiometricResult {",
      "  final bool isSuccess;",
      "  final String? error;",
      "  final List<BiometricType>? availableBiometrics;",
      "",
      "  const BiometricResult._({",
      "    required this.isSuccess,",
      "    this.error,",
      "    this.availableBiometrics,",
      "  });",
      "",
      "  factory BiometricResult.success({",
      "    List<BiometricType>? availableBiometrics,",
      "  }) {",
      "    return BiometricResult._(",
      "      isSuccess: true,",
      "      availableBiometrics: availableBiometrics,",
      "    );",
      "  }",
      "",
      "  factory BiometricResult.failure(String error) {",
      "    return BiometricResult._(",
      "      isSuccess: false,",
      "      error: error,",
      "    );",
      "  }",
      "}",
      "$0"
    ]
  }
}
