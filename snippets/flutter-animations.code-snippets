{
  "Custom Painter Class": {
    "prefix": "fla-painter",
    "description": "Complete custom painter class with animation support",
    "body": [
      "import 'package:flutter/material.dart';",
      "import 'dart:math' as math;",
      "",
      "class ${1:CircleWave}Painter extends CustomPainter {",
      "  const ${1:CircleWave}Painter({",
      "    required this.animation,",
      "    this.color = Colors.blue,",
      "    this.strokeWidth = 3.0,",
      "  });",
      "",
      "  final Animation<double> animation;",
      "  final Color color;",
      "  final double strokeWidth;",
      "",
      "  @override",
      "  void paint(Canvas canvas, Size size) {",
      "    final Paint paint = Paint()",
      "      ..color = color.withOpacity(1.0 - animation.value)",
      "      ..style = PaintingStyle.stroke",
      "      ..strokeWidth = strokeWidth;",
      "",
      "    final center = Offset(size.width / 2, size.height / 2);",
      "    final radius = (size.width / 2) * animation.value;",
      "",
      "    // Main circle",
      "    canvas.drawCircle(center, radius, paint);",
      "",
      "    // Additional waves",
      "    for (int i = 1; i <= 3; i++) {",
      "      final wavePaint = Paint()",
      "        ..color = color.withOpacity((1.0 - animation.value) * 0.3)",
      "        ..style = PaintingStyle.stroke",
      "        ..strokeWidth = strokeWidth / i;",
      "      ",
      "      final waveRadius = radius + (20.0 * i * animation.value);",
      "      if (waveRadius <= size.width / 2) {",
      "        canvas.drawCircle(center, waveRadius, wavePaint);",
      "      }",
      "    }",
      "",
      "    ${2:// Add custom painting logic here}",
      "  }",
      "",
      "  @override",
      "  bool shouldRepaint(covariant ${1:CircleWave}Painter oldDelegate) {",
      "    return oldDelegate.animation.value != animation.value ||",
      "           oldDelegate.color != color ||",
      "           oldDelegate.strokeWidth != strokeWidth;",
      "  }",
      "}",
      "",
      "// Widget to use the custom painter",
      "class ${1:CircleWave}Widget extends StatefulWidget {",
      "  const ${1:CircleWave}Widget({",
      "    super.key,",
      "    this.size = 100.0,",
      "    this.color = Colors.blue,",
      "    this.duration = const Duration(seconds: 2),",
      "  });",
      "",
      "  final double size;",
      "  final Color color;",
      "  final Duration duration;",
      "",
      "  @override",
      "  State<${1:CircleWave}Widget> createState() => _${1:CircleWave}WidgetState();",
      "}",
      "",
      "class _${1:CircleWave}WidgetState extends State<${1:CircleWave}Widget>",
      "    with TickerProviderStateMixin {",
      "  late AnimationController _controller;",
      "  late Animation<double> _animation;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _controller = AnimationController(",
      "      duration: widget.duration,",
      "      vsync: this,",
      "    );",
      "    _animation = Tween<double>(",
      "      begin: 0.0,",
      "      end: 1.0,",
      "    ).animate(CurvedAnimation(",
      "      parent: _controller,",
      "      curve: Curves.easeOut,",
      "    ));",
      "    ",
      "    _controller.repeat();",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _controller.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return AnimatedBuilder(",
      "      animation: _animation,",
      "      builder: (context, child) {",
      "        return SizedBox(",
      "          width: widget.size,",
      "          height: widget.size,",
      "          child: CustomPaint(",
      "            painter: ${1:CircleWave}Painter(",
      "              animation: _animation,",
      "              color: widget.color,",
      "            ),",
      "          ),",
      "        );",
      "      },",
      "    );",
      "  }",
      "}$0"
    ]
  },

  "Fade Transition": {
    "prefix": "fla-fade",
    "description": "Fade in/out animation with controller",
    "body": [
      "class ${1:FadeTransition}Widget extends StatefulWidget {",
      "  const ${1:FadeTransition}Widget({",
      "    super.key,",
      "    required this.child,",
      "    this.duration = const Duration(milliseconds: 500),",
      "    this.curve = Curves.easeInOut,",
      "    this.autoStart = true,",
      "  });",
      "",
      "  final Widget child;",
      "  final Duration duration;",
      "  final Curve curve;",
      "  final bool autoStart;",
      "",
      "  @override",
      "  State<${1:FadeTransition}Widget> createState() => _${1:FadeTransition}WidgetState();",
      "}",
      "",
      "class _${1:FadeTransition}WidgetState extends State<${1:FadeTransition}Widget>",
      "    with SingleTickerProviderStateMixin {",
      "  late AnimationController _controller;",
      "  late Animation<double> _fadeAnimation;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _controller = AnimationController(",
      "      duration: widget.duration,",
      "      vsync: this,",
      "    );",
      "    ",
      "    _fadeAnimation = Tween<double>(",
      "      begin: 0.0,",
      "      end: 1.0,",
      "    ).animate(CurvedAnimation(",
      "      parent: _controller,",
      "      curve: widget.curve,",
      "    ));",
      "",
      "    if (widget.autoStart) {",
      "      _controller.forward();",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _controller.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  void fadeIn() => _controller.forward();",
      "  void fadeOut() => _controller.reverse();",
      "  void toggle() {",
      "    if (_controller.status == AnimationStatus.completed) {",
      "      _controller.reverse();",
      "    } else {",
      "      _controller.forward();",
      "    }",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return FadeTransition(",
      "      opacity: _fadeAnimation,",
      "      child: widget.child,",
      "    );",
      "  }",
      "}$0"
    ]
  },

  "Slide Animation": {
    "prefix": "fla-slide",
    "description": "Slide animation with direction control",
    "body": [
      "class ${1:SlideAnimation}Widget extends StatefulWidget {",
      "  const ${1:SlideAnimation}Widget({",
      "    super.key,",
      "    required this.child,",
      "    this.direction = SlideDirection.bottomToTop,",
      "    this.duration = const Duration(milliseconds: 600),",
      "    this.curve = Curves.easeOutCubic,",
      "    this.offset = 100.0,",
      "    this.autoStart = true,",
      "  });",
      "",
      "  final Widget child;",
      "  final SlideDirection direction;",
      "  final Duration duration;",
      "  final Curve curve;",
      "  final double offset;",
      "  final bool autoStart;",
      "",
      "  @override",
      "  State<${1:SlideAnimation}Widget> createState() => _${1:SlideAnimation}WidgetState();",
      "}",
      "",
      "class _${1:SlideAnimation}WidgetState extends State<${1:SlideAnimation}Widget>",
      "    with SingleTickerProviderStateMixin {",
      "  late AnimationController _controller;",
      "  late Animation<Offset> _slideAnimation;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _controller = AnimationController(",
      "      duration: widget.duration,",
      "      vsync: this,",
      "    );",
      "",
      "    Offset begin;",
      "    switch (widget.direction) {",
      "      case SlideDirection.leftToRight:",
      "        begin = Offset(-widget.offset, 0.0);",
      "        break;",
      "      case SlideDirection.rightToLeft:",
      "        begin = Offset(widget.offset, 0.0);",
      "        break;",
      "      case SlideDirection.topToBottom:",
      "        begin = Offset(0.0, -widget.offset);",
      "        break;",
      "      case SlideDirection.bottomToTop:",
      "        begin = Offset(0.0, widget.offset);",
      "        break;",
      "    }",
      "",
      "    _slideAnimation = Tween<Offset>(",
      "      begin: begin,",
      "      end: Offset.zero,",
      "    ).animate(CurvedAnimation(",
      "      parent: _controller,",
      "      curve: widget.curve,",
      "    ));",
      "",
      "    if (widget.autoStart) {",
      "      _controller.forward();",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _controller.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return SlideTransition(",
      "      position: _slideAnimation,",
      "      child: widget.child,",
      "    );",
      "  }",
      "}",
      "",
      "enum SlideDirection {",
      "  leftToRight,",
      "  rightToLeft,",
      "  topToBottom,",
      "  bottomToTop,",
      "}$0"
    ]
  },

  "Scale Animation": {
    "prefix": "fla-scale",
    "description": "Scale animation with bounce effect",
    "body": [
      "class ${1:ScaleAnimation}Widget extends StatefulWidget {",
      "  const ${1:ScaleAnimation}Widget({",
      "    super.key,",
      "    required this.child,",
      "    this.duration = const Duration(milliseconds: 800),",
      "    this.curve = Curves.elasticOut,",
      "    this.initialScale = 0.0,",
      "    this.finalScale = 1.0,",
      "    this.autoStart = true,",
      "  });",
      "",
      "  final Widget child;",
      "  final Duration duration;",
      "  final Curve curve;",
      "  final double initialScale;",
      "  final double finalScale;",
      "  final bool autoStart;",
      "",
      "  @override",
      "  State<${1:ScaleAnimation}Widget> createState() => _${1:ScaleAnimation}WidgetState();",
      "}",
      "",
      "class _${1:ScaleAnimation}WidgetState extends State<${1:ScaleAnimation}Widget>",
      "    with SingleTickerProviderStateMixin {",
      "  late AnimationController _controller;",
      "  late Animation<double> _scaleAnimation;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _controller = AnimationController(",
      "      duration: widget.duration,",
      "      vsync: this,",
      "    );",
      "",
      "    _scaleAnimation = Tween<double>(",
      "      begin: widget.initialScale,",
      "      end: widget.finalScale,",
      "    ).animate(CurvedAnimation(",
      "      parent: _controller,",
      "      curve: widget.curve,",
      "    ));",
      "",
      "    if (widget.autoStart) {",
      "      _controller.forward();",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _controller.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  void scaleIn() => _controller.forward();",
      "  void scaleOut() => _controller.reverse();",
      "  void bounce() {",
      "    _controller.reset();",
      "    _controller.forward();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return ScaleTransition(",
      "      scale: _scaleAnimation,",
      "      child: widget.child,",
      "    );",
      "  }",
      "}$0"
    ]
  },

  "Rotation Animation": {
    "prefix": "fla-rotation",
    "description": "Rotation animation with control",
    "body": [
      "class ${1:RotationAnimation}Widget extends StatefulWidget {",
      "  const ${1:RotationAnimation}Widget({",
      "    super.key,",
      "    required this.child,",
      "    this.duration = const Duration(seconds: 2),",
      "    this.curve = Curves.linear,",
      "    this.turns = 1.0,",
      "    this.repeat = false,",
      "    this.autoStart = true,",
      "  });",
      "",
      "  final Widget child;",
      "  final Duration duration;",
      "  final Curve curve;",
      "  final double turns;",
      "  final bool repeat;",
      "  final bool autoStart;",
      "",
      "  @override",
      "  State<${1:RotationAnimation}Widget> createState() => _${1:RotationAnimation}WidgetState();",
      "}",
      "",
      "class _${1:RotationAnimation}WidgetState extends State<${1:RotationAnimation}Widget>",
      "    with SingleTickerProviderStateMixin {",
      "  late AnimationController _controller;",
      "  late Animation<double> _rotationAnimation;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _controller = AnimationController(",
      "      duration: widget.duration,",
      "      vsync: this,",
      "    );",
      "",
      "    _rotationAnimation = Tween<double>(",
      "      begin: 0.0,",
      "      end: widget.turns,",
      "    ).animate(CurvedAnimation(",
      "      parent: _controller,",
      "      curve: widget.curve,",
      "    ));",
      "",
      "    if (widget.autoStart) {",
      "      if (widget.repeat) {",
      "        _controller.repeat();",
      "      } else {",
      "        _controller.forward();",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _controller.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  void rotate() => _controller.forward();",
      "  void rotateReverse() => _controller.reverse();",
      "  void startRotation() => _controller.repeat();",
      "  void stopRotation() => _controller.stop();",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return RotationTransition(",
      "      turns: _rotationAnimation,",
      "      child: widget.child,",
      "    );",
      "  }",
      "}$0"
    ]
  },

  "Hero Animation": {
    "prefix": "fla-hero",
    "description": "Hero animation for page transitions",
    "body": [
      "// Source Widget",
      "Hero(",
      "  tag: '${1:unique_hero_tag}',",
      "  child: GestureDetector(",
      "    onTap: () {",
      "      Navigator.of(context).push(",
      "        MaterialPageRoute(",
      "          builder: (context) => ${2:DetailPage}(",
      "            heroTag: '${1:unique_hero_tag}',",
      "          ),",
      "        ),",
      "      );",
      "    },",
      "    child: ${3:Container(",
      "      width: 100,",
      "      height: 100,",
      "      decoration: BoxDecoration(",
      "        color: Theme.of(context).colorScheme.primary,",
      "        borderRadius: BorderRadius.circular(12),",
      "      ),",
      "      child: const Icon(",
      "        Icons.photo,",
      "        color: Colors.white,",
      "        size: 50,",
      "      ),",
      "    ),}",
      "  ),",
      "),",
      "",
      "// Destination Page",
      "class ${2:DetailPage} extends StatelessWidget {",
      "  const ${2:DetailPage}({",
      "    super.key,",
      "    required this.heroTag,",
      "  });",
      "",
      "  final String heroTag;",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Scaffold(",
      "      appBar: AppBar(",
      "        title: const Text('${4:Detail}'),",
      "        backgroundColor: Colors.transparent,",
      "        elevation: 0,",
      "      ),",
      "      body: Column(",
      "        children: [",
      "          Hero(",
      "            tag: heroTag,",
      "            child: Container(",
      "              width: double.infinity,",
      "              height: 300,",
      "              decoration: BoxDecoration(",
      "                color: Theme.of(context).colorScheme.primary,",
      "                borderRadius: const BorderRadius.only(",
      "                  bottomLeft: Radius.circular(24),",
      "                  bottomRight: Radius.circular(24),",
      "                ),",
      "              ),",
      "              child: const Icon(",
      "                Icons.photo,",
      "                color: Colors.white,",
      "                size: 100,",
      "              ),",
      "            ),",
      "          ),",
      "          Expanded(",
      "            child: Padding(",
      "              padding: const EdgeInsets.all(16),",
      "              child: Column(",
      "                crossAxisAlignment: CrossAxisAlignment.start,",
      "                children: [",
      "                  Text(",
      "                    '${5:Detail Title}',",
      "                    style: Theme.of(context).textTheme.headlineMedium,",
      "                  ),",
      "                  const SizedBox(height: 16),",
      "                  Text(",
      "                    '${6:Detail description goes here...}',",
      "                    style: Theme.of(context).textTheme.bodyLarge,",
      "                  ),",
      "                ],",
      "              ),",
      "            ),",
      "          ),",
      "        ],",
      "      ),",
      "    );",
      "  }",
      "}$0"
    ]
  },

  "Staggered Animation": {
    "prefix": "fla-staggered",
    "description": "Staggered animation for multiple children",
    "body": [
      "class ${1:StaggeredAnimation}Widget extends StatefulWidget {",
      "  const ${1:StaggeredAnimation}Widget({",
      "    super.key,",
      "    required this.children,",
      "    this.duration = const Duration(milliseconds: 1200),",
      "    this.staggerDelay = const Duration(milliseconds: 100),",
      "    this.curve = Curves.easeOutBack,",
      "  });",
      "",
      "  final List<Widget> children;",
      "  final Duration duration;",
      "  final Duration staggerDelay;",
      "  final Curve curve;",
      "",
      "  @override",
      "  State<${1:StaggeredAnimation}Widget> createState() => _${1:StaggeredAnimation}WidgetState();",
      "}",
      "",
      "class _${1:StaggeredAnimation}WidgetState extends State<${1:StaggeredAnimation}Widget>",
      "    with TickerProviderStateMixin {",
      "  late List<AnimationController> _controllers;",
      "  late List<Animation<double>> _animations;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _controllers = List.generate(",
      "      widget.children.length,",
      "      (index) => AnimationController(",
      "        duration: widget.duration,",
      "        vsync: this,",
      "      ),",
      "    );",
      "",
      "    _animations = _controllers",
      "        .map((controller) => Tween<double>(",
      "              begin: 0.0,",
      "              end: 1.0,",
      "            ).animate(CurvedAnimation(",
      "              parent: controller,",
      "              curve: widget.curve,",
      "            )))",
      "        .toList();",
      "",
      "    _startStaggeredAnimation();",
      "  }",
      "",
      "  void _startStaggeredAnimation() async {",
      "    for (int i = 0; i < _controllers.length; i++) {",
      "      if (mounted) {",
      "        _controllers[i].forward();",
      "        await Future.delayed(widget.staggerDelay);",
      "      }",
      "    }",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    for (final controller in _controllers) {",
      "      controller.dispose();",
      "    }",
      "    super.dispose();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    return Column(",
      "      children: List.generate(",
      "        widget.children.length,",
      "        (index) => AnimatedBuilder(",
      "          animation: _animations[index],",
      "          builder: (context, child) {",
      "            return Transform.translate(",
      "              offset: Offset(",
      "                0,",
      "                50 * (1 - _animations[index].value),",
      "              ),",
      "              child: Opacity(",
      "                opacity: _animations[index].value,",
      "                child: widget.children[index],",
      "              ),",
      "            );",
      "          },",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}$0"
    ]
  },

  "Page Transition": {
    "prefix": "fla-page-transition",
    "description": "Custom page transition animations",
    "body": [
      "class ${1:Custom}PageTransition extends PageRouteBuilder {",
      "  ${1:Custom}PageTransition({",
      "    required this.child,",
      "    this.type = ${1:Custom}TransitionType.slideUp,",
      "    this.duration = const Duration(milliseconds: 300),",
      "    this.curve = Curves.easeInOut,",
      "    super.settings,",
      "  }) : super(",
      "          pageBuilder: (context, animation, secondaryAnimation) => child,",
      "          transitionDuration: duration,",
      "          transitionsBuilder: (context, animation, secondaryAnimation, child) {",
      "            return _buildTransition(type, animation, child, curve);",
      "          },",
      "        );",
      "",
      "  final Widget child;",
      "  final ${1:Custom}TransitionType type;",
      "  final Duration duration;",
      "  final Curve curve;",
      "",
      "  static Widget _buildTransition(",
      "    ${1:Custom}TransitionType type,",
      "    Animation<double> animation,",
      "    Widget child,",
      "    Curve curve,",
      "  ) {",
      "    final curvedAnimation = CurvedAnimation(",
      "      parent: animation,",
      "      curve: curve,",
      "    );",
      "",
      "    switch (type) {",
      "      case ${1:Custom}TransitionType.fade:",
      "        return FadeTransition(",
      "          opacity: curvedAnimation,",
      "          child: child,",
      "        );",
      "",
      "      case ${1:Custom}TransitionType.scale:",
      "        return ScaleTransition(",
      "          scale: curvedAnimation,",
      "          child: child,",
      "        );",
      "",
      "      case ${1:Custom}TransitionType.rotation:",
      "        return RotationTransition(",
      "          turns: curvedAnimation,",
      "          child: child,",
      "        );",
      "",
      "      case ${1:Custom}TransitionType.slideUp:",
      "        return SlideTransition(",
      "          position: Tween<Offset>(",
      "            begin: const Offset(0.0, 1.0),",
      "            end: Offset.zero,",
      "          ).animate(curvedAnimation),",
      "          child: child,",
      "        );",
      "",
      "      case ${1:Custom}TransitionType.slideLeft:",
      "        return SlideTransition(",
      "          position: Tween<Offset>(",
      "            begin: const Offset(1.0, 0.0),",
      "            end: Offset.zero,",
      "          ).animate(curvedAnimation),",
      "          child: child,",
      "        );",
      "",
      "      case ${1:Custom}TransitionType.scaleRotate:",
      "        return ScaleTransition(",
      "          scale: curvedAnimation,",
      "          child: RotationTransition(",
      "            turns: Tween<double>(",
      "              begin: 0.0,",
      "              end: 0.25,",
      "            ).animate(curvedAnimation),",
      "            child: child,",
      "          ),",
      "        );",
      "    }",
      "  }",
      "}",
      "",
      "enum ${1:Custom}TransitionType {",
      "  fade,",
      "  scale,",
      "  rotation,",
      "  slideUp,",
      "  slideLeft,",
      "  scaleRotate,",
      "}$0"
    ]
  },

  "Loading Animation": {
    "prefix": "fla-loading",
    "description": "Custom loading animation with multiple styles",
    "body": [
      "class ${1:Loading}Animation extends StatefulWidget {",
      "  const ${1:Loading}Animation({",
      "    super.key,",
      "    this.type = LoadingType.dots,",
      "    this.size = 50.0,",
      "    this.color,",
      "    this.duration = const Duration(milliseconds: 1200),",
      "  });",
      "",
      "  final LoadingType type;",
      "  final double size;",
      "  final Color? color;",
      "  final Duration duration;",
      "",
      "  @override",
      "  State<${1:Loading}Animation> createState() => _${1:Loading}AnimationState();",
      "}",
      "",
      "class _${1:Loading}AnimationState extends State<${1:Loading}Animation>",
      "    with TickerProviderStateMixin {",
      "  late AnimationController _controller;",
      "",
      "  @override",
      "  void initState() {",
      "    super.initState();",
      "    _controller = AnimationController(",
      "      duration: widget.duration,",
      "      vsync: this,",
      "    );",
      "    _controller.repeat();",
      "  }",
      "",
      "  @override",
      "  void dispose() {",
      "    _controller.dispose();",
      "    super.dispose();",
      "  }",
      "",
      "  @override",
      "  Widget build(BuildContext context) {",
      "    final color = widget.color ?? Theme.of(context).colorScheme.primary;",
      "",
      "    return SizedBox(",
      "      width: widget.size,",
      "      height: widget.size,",
      "      child: AnimatedBuilder(",
      "        animation: _controller,",
      "        builder: (context, child) {",
      "          switch (widget.type) {",
      "            case LoadingType.dots:",
      "              return _buildDotsLoading(color);",
      "            case LoadingType.pulse:",
      "              return _buildPulseLoading(color);",
      "            case LoadingType.wave:",
      "              return _buildWaveLoading(color);",
      "            case LoadingType.spinner:",
      "              return _buildSpinnerLoading(color);",
      "          }",
      "        },",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildDotsLoading(Color color) {",
      "    return Row(",
      "      mainAxisAlignment: MainAxisAlignment.spaceEvenly,",
      "      children: List.generate(3, (index) {",
      "        final delay = index * 0.2;",
      "        final animValue = (_controller.value - delay).clamp(0.0, 1.0);",
      "        final scale = 0.5 + (0.5 * math.sin(animValue * math.pi * 2));",
      "        ",
      "        return Transform.scale(",
      "          scale: scale,",
      "          child: Container(",
      "            width: widget.size / 6,",
      "            height: widget.size / 6,",
      "            decoration: BoxDecoration(",
      "              color: color,",
      "              shape: BoxShape.circle,",
      "            ),",
      "          ),",
      "        );",
      "      }),",
      "    );",
      "  }",
      "",
      "  Widget _buildPulseLoading(Color color) {",
      "    final scale = 0.7 + (0.3 * math.sin(_controller.value * math.pi * 2));",
      "    final opacity = 0.5 + (0.5 * math.sin(_controller.value * math.pi * 2));",
      "    ",
      "    return Transform.scale(",
      "      scale: scale,",
      "      child: Container(",
      "        decoration: BoxDecoration(",
      "          color: color.withOpacity(opacity),",
      "          shape: BoxShape.circle,",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "",
      "  Widget _buildWaveLoading(Color color) {",
      "    return Row(",
      "      mainAxisAlignment: MainAxisAlignment.spaceEvenly,",
      "      children: List.generate(4, (index) {",
      "        final delay = index * 0.1;",
      "        final animValue = (_controller.value - delay).clamp(0.0, 1.0);",
      "        final height = widget.size * (0.3 + 0.7 * math.sin(animValue * math.pi * 2));",
      "        ",
      "        return Container(",
      "          width: widget.size / 8,",
      "          height: height,",
      "          decoration: BoxDecoration(",
      "            color: color,",
      "            borderRadius: BorderRadius.circular(widget.size / 16),",
      "          ),",
      "        );",
      "      }),",
      "    );",
      "  }",
      "",
      "  Widget _buildSpinnerLoading(Color color) {",
      "    return Transform.rotate(",
      "      angle: _controller.value * 2 * math.pi,",
      "      child: Container(",
      "        decoration: BoxDecoration(",
      "          border: Border.all(",
      "            color: color.withOpacity(0.3),",
      "            width: 3.0,",
      "          ),",
      "          borderRadius: BorderRadius.circular(widget.size / 2),",
      "        ),",
      "        child: Container(",
      "          decoration: BoxDecoration(",
      "            border: Border(",
      "              top: BorderSide(",
      "                color: color,",
      "                width: 3.0,",
      "              ),",
      "            ),",
      "            borderRadius: BorderRadius.circular(widget.size / 2),",
      "          ),",
      "        ),",
      "      ),",
      "    );",
      "  }",
      "}",
      "",
      "enum LoadingType {",
      "  dots,",
      "  pulse,",
      "  wave,",
      "  spinner,",
      "}$0"
    ]
  }
}
