{
  "Service Class": {
    "prefix": "clean-service",
    "description": "Complete service class with business logic and coordination",
    "body": [
      "import 'package:dartz/dartz.dart';",
      "import 'package:injectable/injectable.dart';",
      "",
      "import '../domain/entities/${1:user}.dart';",
      "import '../domain/failures/${2:domain}_failure.dart';",
       "    // e.g., send welcome email, create audit log, etc.",
      "    // This is where you\\'d integrate with other services",   "import '../domain/usecases/create_${1:user}_usecase.dart';",
      "import '../domain/usecases/get_${1:user}_by_id_usecase.dart';",
      "import '../domain/usecases/update_${1:user}_usecase.dart';",
      "import '../domain/usecases/search_${1:user}s_usecase.dart';",
      "",
      "@lazySingleton",
      "class ${3:User}Service {",
      "  final Create${3:User}UseCase _create${3:User}UseCase;",
      "  final Get${3:User}ByIdUseCase _get${3:User}ByIdUseCase;",
      "  final Update${3:User}UseCase _update${3:User}UseCase;",
      "  final Search${3:User}sUseCase _search${3:User}sUseCase;",
      "",
      "  const ${3:User}Service({",
      "    required Create${3:User}UseCase create${3:User}UseCase,",
      "    required Get${3:User}ByIdUseCase get${3:User}ByIdUseCase,",
      "    required Update${3:User}UseCase update${3:User}UseCase,",
      "    required Search${3:User}sUseCase search${3:User}sUseCase,",
      "  }) : _create${3:User}UseCase = create${3:User}UseCase,",
      "       _get${3:User}ByIdUseCase = get${3:User}ByIdUseCase,",
      "       _update${3:User}UseCase = update${3:User}UseCase,",
      "       _search${3:User}sUseCase = search${3:User}sUseCase;",
      "",
      "  /// Creates a new ${4:user} with comprehensive validation",
      "  Future<Either<${2:Domain}Failure, ${1:User}>> create${3:User}({",
      "    required String name,",
      "    required String email,",
      "    Map<String, dynamic>? metadata,",
      "  }) async {",
      "    // Additional service-level validation",
      "    final validationResult = _validateCreate${3:User}Input(",
      "      name: name,",
      "      email: email,",
      "    );",
      "",
      "    if (validationResult.isLeft()) {",
      "      return validationResult.fold(",
      "        (failure) => left(failure),",
      "        (_) => throw Exception('Unexpected state'),",
      "      );",
      "    }",
      "",
      "    // Apply business transformations",
      "    final normalizedName = _normalizeName(name);",
      "    final normalizedEmail = _normalizeEmail(email);",
      "",
      "    // Execute use case",
      "    final params = Create${3:User}Params(",
      "      name: normalizedName,",
      "      email: normalizedEmail,",
      "      metadata: metadata,",
      "    );",
      "",
      "    final result = await _create${3:User}UseCase(params);",
      "",
      "    return result.fold(",
      "      (failure) => left(failure),",
      "      (${4:user}) async {",
      "        // Post-creation business logic",
      "        await _handlePostCreation(${4:user});",
      "        return right(${4:user});",
      "      },",
      "    );",
      "  }",
      "",
      "  /// Retrieves a ${4:user} by ID with caching strategy",
      "  Future<Either<${2:Domain}Failure, ${1:User}>> get${3:User}ById(",
      "    String id, {",
      "    bool forceRefresh = false,",
      "  }) async {",
      "    if (id.trim().isEmpty) {",
      "      return left(const ${2:Domain}Failure.validationError(",
      "        field: 'id',",
      "        message: 'ID cannot be empty',",
      "      ));",
      "    }",
      "",
      "    final params = Get${3:User}ByIdParams(",
      "      id: id,",
      "      markAsAccessed: true,",
      "    );",
      "",
      "    final result = await _get${3:User}ByIdUseCase(params);",
      "",
      "    return result.fold(",
      "      (failure) => left(failure),",
      "      (${4:user}) async {",
      "        // Post-retrieval business logic",
      "        await _handlePostRetrieval(${4:user});",
      "        return right(${4:user});",
      "      },",
      "    );",
      "  }",
      "",
      "  /// Updates a ${4:user} with validation and business rules",
      "  Future<Either<${2:Domain}Failure, ${1:User}>> update${3:User}({",
      "    required String id,",
      "    String? name,",
      "    String? email,",
      "    Map<String, dynamic>? metadata,",
      "  }) async {",
      "    // Validate update inputs",
      "    final validationResult = _validateUpdate${3:User}Input(",
      "      id: id,",
      "      name: name,",
      "      email: email,",
      "    );",
      "",
      "    if (validationResult.isLeft()) {",
      "      return validationResult.fold(",
      "        (failure) => left(failure),",
      "        (_) => throw Exception('Unexpected state'),",
      "      );",
      "    }",
      "",
      "    // Apply transformations",
      "    final normalizedName = name != null ? _normalizeName(name) : null;",
      "    final normalizedEmail = email != null ? _normalizeEmail(email) : null;",
      "",
      "    // Execute use case",
      "    final params = Update${3:User}Params(",
      "      id: id,",
      "      name: normalizedName,",
      "      email: normalizedEmail,",
      "      metadata: metadata,",
      "    );",
      "",
      "    final result = await _update${3:User}UseCase(params);",
      "",
      "    return result.fold(",
      "      (failure) => left(failure),",
      "      (${4:user}) async {",
      "        // Post-update business logic",
      "        await _handlePostUpdate(${4:user});",
      "        return right(${4:user});",
      "      },",
      "    );",
      "  }",
      "",
      "  /// Advanced ${4:user} search with business-specific filtering",
      "  Future<Either<${2:Domain}Failure, SearchResult<${1:User}>>> search${3:User}s({",
      "    String? query,",
      "    Map<String, dynamic>? filters,",
      "    String? sortBy,",
      "    bool ascending = true,",
      "    int? limit,",
      "    int? offset,",
      "    bool activeOnly = false,",
      "    DateTime? createdAfter,",
      "    DateTime? createdBefore,",
      "  }) async {",
      "    // Apply service-level business rules to filters",
      "    final enhancedFilters = _enhanceSearchFilters(",
      "      originalFilters: filters,",
      "      activeOnly: activeOnly,",
      "      createdAfter: createdAfter,",
      "      createdBefore: createdBefore,",
      "    );",
      "",
      "    // Normalize query",
      "    final normalizedQuery = query?.trim().toLowerCase();",
      "",
      "    final params = Search${3:User}sParams(",
      "      query: normalizedQuery,",
      "      filters: enhancedFilters,",
      "      sortBy: sortBy ?? 'created_at',",
      "      ascending: ascending,",
      "      limit: limit,",
      "      offset: offset,",
      "      activeOnly: activeOnly,",
      "      createdAfter: createdAfter,",
      "      createdBefore: createdBefore,",
      "    );",
      "",
      "    final result = await _search${3:User}sUseCase(params);",
      "",
      "    return result.fold(",
      "      (failure) => left(failure),",
      "      (searchResult) async {",
      "        // Apply post-search business logic",
      "        final processedResult = await _processSearchResults(searchResult);",
      "        return right(processedResult);",
      "      },",
      "    );",
      "  }",
      "",
      "  /// Business-specific ${4:user} operations",
      "  Future<Either<${2:Domain}Failure, List<${1:User}>>> getActive${3:User}s() async {",
      "    return search${3:User}s(activeOnly: true).then((result) {",
      "      return result.fold(",
      "        (failure) => left(failure),",
      "        (searchResult) => right(searchResult.items),",
      "      );",
      "    });",
      "  }",
      "",
      "  Future<Either<${2:Domain}Failure, List<${1:User}>>> getRecent${3:User}s({",
      "    int days = 7,",
      "  }) async {",
      "    final cutoffDate = DateTime.now().subtract(Duration(days: days));",
      "    return search${3:User}s(createdAfter: cutoffDate).then((result) {",
      "      return result.fold(",
      "        (failure) => left(failure),",
      "        (searchResult) => right(searchResult.items),",
      "      );",
      "    });",
      "  }",
      "",
      "  Future<Either<${2:Domain}Failure, ${1:User}?>> find${3:User}ByEmail(String email) async {",
      "    if (!_isValidEmail(email)) {",
      "      return left(const ${2:Domain}Failure.validationError(",
      "        field: 'email',",
      "        message: 'Invalid email format',",
      "      ));",
      "    }",
      "",
      "    return search${3:User}s(",
      "      filters: {'email': _normalizeEmail(email)},",
      "      limit: 1,",
      "    ).then((result) {",
      "      return result.fold(",
      "        (failure) => left(failure),",
      "        (searchResult) => right(",
      "          searchResult.items.isNotEmpty ? searchResult.items.first : null,",
      "        ),",
      "      );",
      "    });",
      "  }",
      "",
      "  /// Complex business operations",
      "  Future<Either<${2:Domain}Failure, ${1:User}>> activate${3:User}(String id) async {",
      "    return update${3:User}(",
      "      id: id,",
      "      metadata: {'is_active': true, 'activated_at': DateTime.now().toIso8601String()},",
      "    );",
      "  }",
      "",
      "  Future<Either<${2:Domain}Failure, ${1:User}>> deactivate${3:User}(String id) async {",
      "    return update${3:User}(",
      "      id: id,",
      "      metadata: {'is_active': false, 'deactivated_at': DateTime.now().toIso8601String()},",
      "    );",
      "  }",
      "",
      "  Future<Either<${2:Domain}Failure, ${1:User}>> archive${3:User}(String id) async {",
      "    return update${3:User}(",
      "      id: id,",
      "      metadata: {",
      "        'is_archived': true,",
      "        'archived_at': DateTime.now().toIso8601String(),",
      "      },",
      "    );",
      "  }",
      "",
      "  // Private helper methods",
      "  Either<${2:Domain}Failure, Unit> _validateCreate${3:User}Input({",
      "    required String name,",
      "    required String email,",
      "  }) {",
      "    if (name.trim().isEmpty) {",
      "      return left(const ${2:Domain}Failure.validationError(",
      "        field: 'name',",
      "        message: 'Name cannot be empty',",
      "      ));",
      "    }",
      "",
      "    if (!_isValidEmail(email)) {",
      "      return left(const ${2:Domain}Failure.validationError(",
      "        field: 'email',",
      "        message: 'Invalid email format',",
      "      ));",
      "    }",
      "",
      "    // Additional business-specific validations",
      "    if (name.trim().length < 2) {",
      "      return left(const ${2:Domain}Failure.businessRuleViolation(",
      "        'Name must be at least 2 characters long',",
      "      ));",
      "    }",
      "",
      "    if (_isDisposableEmail(email)) {",
      "      return left(const ${2:Domain}Failure.businessRuleViolation(",
      "        'Disposable email addresses are not allowed',",
      "      ));",
      "    }",
      "",
      "    return right(unit);",
      "  }",
      "",
      "  Either<${2:Domain}Failure, Unit> _validateUpdate${3:User}Input({",
      "    required String id,",
      "    String? name,",
      "    String? email,",
      "  }) {",
      "    if (id.trim().isEmpty) {",
      "      return left(const ${2:Domain}Failure.validationError(",
      "        field: 'id',",
      "        message: 'ID cannot be empty',",
      "      ));",
      "    }",
      "",
      "    if (name != null && name.trim().length < 2) {",
      "      return left(const ${2:Domain}Failure.validationError(",
      "        field: 'name',",
      "        message: 'Name must be at least 2 characters long',",
      "      ));",
      "    }",
      "",
      "    if (email != null && !_isValidEmail(email)) {",
      "      return left(const ${2:Domain}Failure.validationError(",
      "        field: 'email',",
      "        message: 'Invalid email format',",
      "      ));",
      "    }",
      "",
      "    return right(unit);",
      "  }",
      "",
      "  String _normalizeName(String name) {",
      "    return name.trim()",
      "        .split(' ')",
      "        .map((part) => part.isEmpty ? '' : part[0].toUpperCase() + part.substring(1).toLowerCase())",
      "        .where((part) => part.isNotEmpty)",
      "        .join(' ');",
      "  }",
      "",
      "  String _normalizeEmail(String email) {",
      "    return email.trim().toLowerCase();",
      "  }",
      "",
      "  bool _isValidEmail(String email) {",
      "    final emailRegex = RegExp(r'^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$');",
      "    return emailRegex.hasMatch(email);",
      "  }",
      "",
      "  bool _isDisposableEmail(String email) {",
      "    final disposableDomains = [",
      "      '10minutemail.com',",
      "      'tempmail.org',",
      "      'guerrillamail.com',",
      "      'mailinator.com',",
      "      // Add more disposable domains as needed",
      "    ];",
      "",
      "    final domain = email.split('@').last.toLowerCase();",
      "    return disposableDomains.contains(domain);",
      "  }",
      "",
      "  Map<String, dynamic> _enhanceSearchFilters({",
      "    Map<String, dynamic>? originalFilters,",
      "    bool activeOnly = false,",
      "    DateTime? createdAfter,",
      "    DateTime? createdBefore,",
      "  }) {",
      "    final filters = <String, dynamic>{...?originalFilters};",
      "",
      "    if (activeOnly) {",
      "      filters['is_active'] = true;",
      "    }",
      "",
      "    if (createdAfter != null) {",
      "      filters['created_after'] = createdAfter.toIso8601String();",
      "    }",
      "",
      "    if (createdBefore != null) {",
      "      filters['created_before'] = createdBefore.toIso8601String();",
      "    }",
      "",
      "    // Add business-specific filters",
      "    filters['exclude_archived'] = true;",
      "",
      "    return filters;",
      "  }",
      "",
      "  Future<void> _handlePostCreation(${1:User} ${4:user}) async {",
      "    // Implement post-creation business logic",
      "    // e.g., send welcome email, create audit log, etc.",",
      "    // This is where you\\'d integrate with other services",
      "  }",
      "",
      "  Future<void> _handlePostRetrieval(${1:User} ${4:user}) async {",
      "    // Implement post-retrieval business logic",
      "    // e.g., update last accessed timestamp, log access, etc.",
      "  }",
      "",
      "  Future<void> _handlePostUpdate(${1:User} ${4:user}) async {",
      "    // Implement post-update business logic",
      "    // e.g., send notification, update search index, etc.",
      "  }",
      "",
      "  Future<SearchResult<${1:User}>> _processSearchResults(",
      "    SearchResult<${1:User}> searchResult,",
      "  ) async {",
      "    // Apply any post-search processing",
      "    // e.g., add computed fields, apply business transformations, etc.",
      "    return searchResult;",
      "  }",
      "}",
      "$0"
    ]
  },

  "GetIt Service Locator": {
    "prefix": "clean-getit-setup",
    "description": "Complete GetIt dependency injection setup",
    "body": [
      "import 'package:dio/dio.dart';",
      "import 'package:get_it/get_it.dart';",
      "import 'package:hive/hive.dart';",
      "import 'package:injectable/injectable.dart';",
      "",
      "import 'data/datasources/${1:user}_http_datasource.dart';",
      "import 'data/datasources/${1:user}_hive_datasource.dart';",
      "import 'data/datasources/${1:user}_local_datasource.dart';",
      "import 'data/datasources/${1:user}_remote_datasource.dart';",
      "import 'data/repositories/${1:user}_repository_impl.dart';",
      "import 'domain/repositories/${1:user}_repository.dart';",
      "import 'domain/usecases/create_${1:user}_usecase.dart';",
      "import 'domain/usecases/get_${1:user}_by_id_usecase.dart';",
      "import 'domain/usecases/update_${1:user}_usecase.dart';",
      "import 'domain/usecases/search_${1:user}s_usecase.dart';",
      "import 'services/${1:user}_service.dart';",
      "",
      "final getIt = GetIt.instance;",
      "",
      "@InjectableInit()",
      "Future<void> configureDependencies() async {",
      "  // Initialize Hive",
      "  await _initializeHive();",
      "",
      "  // Register external dependencies",
      "  _registerExternalDependencies();",
      "",
      "  // Register data sources",
      "  _registerDataSources();",
      "",
      "  // Register repositories",
      "  _registerRepositories();",
      "",
      "  // Register use cases",
      "  _registerUseCases();",
      "",
      "  // Register services",
      "  _registerServices();",
      "",
      "  // Register presentation layer dependencies",
      "  _registerPresentationDependencies();",
      "}",
      "",
      "Future<void> _initializeHive() async {",
      "  await ${2:User}HiveDataSource.init();",
      "}",
      "",
      "void _registerExternalDependencies() {",
      "  // Register Dio with interceptors",
      "  getIt.registerLazySingleton<Dio>(() {",
      "    final dio = Dio();",
      "    ",
      "    // Add interceptors",
      "    dio.interceptors.addAll([",
      "      _createAuthInterceptor(),",
      "      _createLoggingInterceptor(),",
      "      _createRetryInterceptor(),",
      "      _createErrorInterceptor(),",
      "    ]);",
      "",
      "    // Configure options",
      "    dio.options = BaseOptions(",
      "      baseUrl: _getBaseUrl(),",
      "      connectTimeout: const Duration(seconds: 30),",
      "      receiveTimeout: const Duration(seconds: 30),",
      "      sendTimeout: const Duration(seconds: 30),",
      "      headers: {",
      "        'Content-Type': 'application/json',",
      "        'Accept': 'application/json',",
      "      },",
      "    );",
      "",
      "    return dio;",
      "  });",
      "",
      "  // Register configuration",
      "  getIt.registerLazySingleton<AppConfig>(() => AppConfig());",
      "}",
      "",
      "void _registerDataSources() {",
      "  // Register remote data source",
      "  getIt.registerLazySingleton<${2:User}RemoteDataSource>(",
      "    () => ${2:User}HttpDataSource(",
      "      dio: getIt<Dio>(),",
      "      baseUrl: getIt<AppConfig>().apiBaseUrl,",
      "    ),",
      "  );",
      "",
      "  // Register local data source",
      "  getIt.registerLazySingleton<${2:User}LocalDataSource>(",
      "    () => ${2:User}HiveDataSource(),",
      "  );",
      "}",
      "",
      "void _registerRepositories() {",
      "  getIt.registerLazySingleton<${2:User}Repository>(",
      "    () => ${2:User}RepositoryImpl(",
      "      remoteDataSource: getIt<${2:User}RemoteDataSource>(),",
      "      localDataSource: getIt<${2:User}LocalDataSource>(),",
      "    ),",
      "  );",
      "}",
      "",
      "void _registerUseCases() {",
      "  // Register all use cases",
      "  getIt.registerLazySingleton<Create${2:User}UseCase>(",
      "    () => Create${2:User}UseCase(getIt<${2:User}Repository>()),",
      "  );",
      "",
      "  getIt.registerLazySingleton<Get${2:User}ByIdUseCase>(",
      "    () => Get${2:User}ByIdUseCase(getIt<${2:User}Repository>()),",
      "  );",
      "",
      "  getIt.registerLazySingleton<Update${2:User}UseCase>(",
      "    () => Update${2:User}UseCase(getIt<${2:User}Repository>()),",
      "  );",
      "",
      "  getIt.registerLazySingleton<Search${2:User}sUseCase>(",
      "    () => Search${2:User}sUseCase(getIt<${2:User}Repository>()),",
      "  );",
      "}",
      "",
      "void _registerServices() {",
      "  getIt.registerLazySingleton<${2:User}Service>(",
      "    () => ${2:User}Service(",
      "      create${2:User}UseCase: getIt<Create${2:User}UseCase>(),",
      "      get${2:User}ByIdUseCase: getIt<Get${2:User}ByIdUseCase>(),",
      "      update${2:User}UseCase: getIt<Update${2:User}UseCase>(),",
      "      search${2:User}sUseCase: getIt<Search${2:User}sUseCase>(),",
      "    ),",
      "  );",
      "}",
      "",
      "void _registerPresentationDependencies() {",
      "  // Register BLoCs, Cubits, ViewModels, etc.",
      "  getIt.registerFactory<${2:User}Bloc>(",
      "    () => ${2:User}Bloc(",
      "      ${3:user}Service: getIt<${2:User}Service>(),",
      "    ),",
      "  );",
      "",
      "  getIt.registerFactory<${2:User}ListCubit>(",
      "    () => ${2:User}ListCubit(",
      "      ${3:user}Service: getIt<${2:User}Service>(),",
      "    ),",
      "  );",
      "}",
      "",
      "// Helper methods for creating interceptors",
      "Interceptor _createAuthInterceptor() {",
      "  return InterceptorsWrapper(",
      "    onRequest: (options, handler) async {",
      "      // Add authentication token",
      "      final token = await _getAuthToken();",
      "      if (token != null) {",
      "        options.headers['Authorization'] = 'Bearer \\$token';",
      "      }",
      "      handler.next(options);",
      "    },",
      "    onError: (error, handler) async {",
      "      // Handle token expiration",
      "      if (error.response?.statusCode == 401) {",
      "        final newToken = await _refreshAuthToken();",
      "        if (newToken != null) {",
      "          // Retry the request with new token",
      "          final options = error.requestOptions;",
      "          options.headers['Authorization'] = 'Bearer \\$newToken';",
      "          final dio = getIt<Dio>();",
      "          try {",
      "            final response = await dio.fetch(options);",
      "            handler.resolve(response);",
      "            return;",
      "          } catch (e) {",
      "            // If retry fails, continue with original error",
      "          }",
      "        }",
      "      }",
      "      handler.next(error);",
      "    },",
      "  );",
      "}",
      "",
      "Interceptor _createLoggingInterceptor() {",
      "  return LogInterceptor(",
      "    requestBody: true,",
      "    responseBody: true,",
      "    error: true,",
      "    requestHeader: false,",
      "    responseHeader: false,",
      "    logPrint: (object) {",
      "      // Use your preferred logging solution",
      "      print(object);",
      "    },",
      "  );",
      "}",
      "",
      "Interceptor _createRetryInterceptor() {",
      "  return InterceptorsWrapper(",
      "    onError: (error, handler) async {",
      "      if (_shouldRetry(error)) {",
      "        const maxRetries = 3;",
      "        int retryCount = error.requestOptions.extra['retryCount'] ?? 0;",
      "",
      "        if (retryCount < maxRetries) {",
      "          retryCount++;",
      "          error.requestOptions.extra['retryCount'] = retryCount;",
      "",
      "          // Exponential backoff",
      "          await Future.delayed(Duration(seconds: retryCount * 2));",
      "",
      "          try {",
      "            final dio = getIt<Dio>();",
      "            final response = await dio.fetch(error.requestOptions);",
      "            handler.resolve(response);",
      "            return;",
      "          } catch (e) {",
      "            // Continue to next retry or fail",
      "          }",
      "        }",
      "      }",
      "      handler.next(error);",
      "    },",
      "  );",
      "}",
      "",
      "Interceptor _createErrorInterceptor() {",
      "  return InterceptorsWrapper(",
      "    onError: (error, handler) {",
      "      // Global error handling",
      "      _logError(error);",
      "      _reportError(error);",
      "      handler.next(error);",
      "    },",
      "  );",
      "}",
      "",
      "bool _shouldRetry(DioException error) {",
      "  return error.type == DioExceptionType.connectionTimeout ||",
      "      error.type == DioExceptionType.receiveTimeout ||",
      "      error.type == DioExceptionType.sendTimeout ||",
      "      (error.response?.statusCode != null && error.response!.statusCode! >= 500);",
      "}",
      "",
      "String _getBaseUrl() {",
      "  // Return appropriate base URL based on environment",
      "  const environment = String.fromEnvironment('ENVIRONMENT', defaultValue: 'development');",
      "  ",
      "  switch (environment) {",
      "    case 'production':",
      "      return 'https://api.yourapp.com';",
      "    case 'staging':",
      "      return 'https://api-staging.yourapp.com';",
      "    default:",
      "      return 'http://localhost:3000';",
      "  }",
      "}",
      "",
      "Future<String?> _getAuthToken() async {",
      "  // Implement token retrieval from secure storage",
      "  return null;",
      "}",
      "",
      "Future<String?> _refreshAuthToken() async {",
      "  // Implement token refresh logic",
      "  return null;",
      "}",
      "",
      "void _logError(DioException error) {",
      "  // Implement error logging",
      "  print('API Error: \\${error.message}');",
      "}",
      "",
      "void _reportError(DioException error) {",
      "  // Implement error reporting (e.g., Crashlytics, Sentry)",
      "}",
      "",
      "class AppConfig {",
      "  String get apiBaseUrl => _getBaseUrl();",
      "  ",
      "  bool get isProduction => ",
      "      const String.fromEnvironment('ENVIRONMENT') == 'production';",
      "  ",
      "  bool get enableLogging => !isProduction;",
      "  ",
      "  Duration get cacheTimeout => const Duration(minutes: 5);",
      "  ",
      "  int get maxRetries => 3;",
      "}",
      "",
      "// Extension for easy access to services",
      "extension GetItExtensions on GetIt {",
      "  T service<T extends Object>() => get<T>();",
      "}",
      "",
      "// Helper for registering environment-specific dependencies",
      "void registerEnvironmentDependencies() {",
      "  const environment = String.fromEnvironment('ENVIRONMENT', defaultValue: 'development');",
      "  ",
      "  switch (environment) {",
      "    case 'test':",
      "      _registerTestDependencies();",
      "      break;",
      "    case 'development':",
      "      _registerDevelopmentDependencies();",
      "      break;",
      "    case 'production':",
      "      _registerProductionDependencies();",
      "      break;",
      "  }",
      "}",
      "",
      "void _registerTestDependencies() {",
      "  // Register test-specific dependencies (mocks, etc.)",
      "}",
      "",
      "void _registerDevelopmentDependencies() {",
      "  // Register development-specific dependencies",
      "}",
      "",
      "void _registerProductionDependencies() {",
      "  // Register production-specific dependencies",
      "}",
      "$0"
    ]
  },

  "Injectable Module": {
    "prefix": "clean-injectable-module",
    "description": "Injectable module for third party dependencies",
    "body": [
      "import 'package:dio/dio.dart';",
      "import 'package:hive/hive.dart';",
      "import 'package:injectable/injectable.dart';",
      "import 'package:shared_preferences/shared_preferences.dart';",
      "",
      "@module",
      "abstract class RegisterModule {",
      "  @lazySingleton",
      "  Dio get dio {",
      "    final dio = Dio();",
      "    ",
      "    // Configure base options",
      "    dio.options = BaseOptions(",
      "      baseUrl: _getBaseUrl(),",
      "      connectTimeout: const Duration(seconds: 30),",
      "      receiveTimeout: const Duration(seconds: 30),",
      "      sendTimeout: const Duration(seconds: 30),",
      "      headers: {",
      "        'Content-Type': 'application/json',",
      "        'Accept': 'application/json',",
      "      },",
      "    );",
      "",
      "    // Add interceptors",
      "    if (_shouldAddLoggingInterceptor()) {",
      "      dio.interceptors.add(",
      "        LogInterceptor(",
      "          requestBody: true,",
      "          responseBody: true,",
      "          error: true,",
      "          requestHeader: false,",
      "          responseHeader: false,",
      "        ),",
      "      );",
      "    }",
      "",
      "    // Add authentication interceptor",
      "    dio.interceptors.add(_createAuthInterceptor());",
      "",
      "    // Add retry interceptor",
      "    dio.interceptors.add(_createRetryInterceptor());",
      "",
      "    return dio;",
      "  }",
      "",
      "  @preResolve",
      "  Future<SharedPreferences> get prefs => SharedPreferences.getInstance();",
      "",
      "  @preResolve",
      "  Future<HiveInterface> get hive async {",
      "    await Hive.initFlutter();",
      "    return Hive;",
      "  }",
      "",
      "  @lazySingleton",
      "  AppConfig get appConfig => AppConfig();",
      "",
      "  // Helper methods",
      "  String _getBaseUrl() {",
      "    const environment = String.fromEnvironment('ENVIRONMENT', defaultValue: 'development');",
      "    ",
      "    switch (environment) {",
      "      case 'production':",
      "        return 'https://api.yourapp.com/v1';",
      "      case 'staging':",
      "        return 'https://api-staging.yourapp.com/v1';",
      "      default:",
      "        return 'http://localhost:3000/v1';",
      "    }",
      "  }",
      "",
      "  bool _shouldAddLoggingInterceptor() {",
      "    const environment = String.fromEnvironment('ENVIRONMENT', defaultValue: 'development');",
      "    return environment != 'production';",
      "  }",
      "",
      "  Interceptor _createAuthInterceptor() {",
      "    return InterceptorsWrapper(",
      "      onRequest: (options, handler) async {",
      "        // Add authentication logic here",
      "        // Example: Get token from secure storage",
      "        final token = await _getStoredToken();",
      "        if (token != null && token.isNotEmpty) {",
      "          options.headers['Authorization'] = 'Bearer \\$token';",
      "        }",
      "        handler.next(options);",
      "      },",
      "      onError: (error, handler) async {",
      "        if (error.response?.statusCode == 401) {",
      "          // Handle token refresh or logout",
      "          await _handleUnauthorized();",
      "        }",
      "        handler.next(error);",
      "      },",
      "    );",
      "  }",
      "",
      "  Interceptor _createRetryInterceptor() {",
      "    return InterceptorsWrapper(",
      "      onError: (error, handler) async {",
      "        if (_shouldRetryRequest(error)) {",
      "          const maxRetries = 3;",
      "          int retryCount = error.requestOptions.extra['retryCount'] ?? 0;",
      "",
      "          if (retryCount < maxRetries) {",
      "            retryCount++;",
      "            error.requestOptions.extra['retryCount'] = retryCount;",
      "",
      "            // Exponential backoff",
      "            final delay = Duration(seconds: retryCount * 2);",
      "            await Future.delayed(delay);",
      "",
      "            try {",
      "              final dio = Dio();",
      "              final response = await dio.fetch(error.requestOptions);",
      "              handler.resolve(response);",
      "              return;",
      "            } catch (e) {",
      "              // Continue with the error if retry fails",
      "            }",
      "          }",
      "        }",
      "        handler.next(error);",
      "      },",
      "    );",
      "  }",
      "",
      "  bool _shouldRetryRequest(DioException error) {",
      "    return error.type == DioExceptionType.connectionTimeout ||",
      "        error.type == DioExceptionType.receiveTimeout ||",
      "        error.type == DioExceptionType.sendTimeout ||",
      "        (error.response?.statusCode != null && ",
      "         error.response!.statusCode! >= 500);",
      "  }",
      "",
      "  Future<String?> _getStoredToken() async {",
      "    // Implement secure token retrieval",
      "    // Example using flutter_secure_storage:",
      "    // const storage = FlutterSecureStorage();",
      "    // return await storage.read(key: 'auth_token');",
      "    return null;",
      "  }",
      "",
      "  Future<void> _handleUnauthorized() async {",
      "    // Implement unauthorized handling",
      "    // Example: Clear stored tokens, navigate to login",
      "  }",
      "}",
      "",
      "class AppConfig {",
      "  String get environment => ",
      "      const String.fromEnvironment('ENVIRONMENT', defaultValue: 'development');",
      "",
      "  bool get isProduction => environment == 'production';",
      "  bool get isDevelopment => environment == 'development';",
      "  bool get isStaging => environment == 'staging';",
      "  bool get isTest => environment == 'test';",
      "",
      "  String get apiBaseUrl {",
      "    switch (environment) {",
      "      case 'production':",
      "        return 'https://api.yourapp.com/v1';",
      "      case 'staging':",
      "        return 'https://api-staging.yourapp.com/v1';",
      "      default:",
      "        return 'http://localhost:3000/v1';",
      "    }",
      "  }",
      "",
      "  Duration get networkTimeout => const Duration(seconds: 30);",
      "  Duration get cacheTimeout => const Duration(minutes: 5);",
      "  int get maxRetries => 3;",
      "  bool get enableLogging => !isProduction;",
      "",
      "  // Feature flags",
      "  bool get enableOfflineMode => true;",
      "  bool get enableAnalytics => isProduction || isStaging;",
      "  bool get enableCrashReporting => isProduction || isStaging;",
      "",
      "  // API endpoints",
      "  String get usersEndpoint => '\\$apiBaseUrl/${1:users}';",
      "  String get authEndpoint => '\\$apiBaseUrl/auth';",
      "  String get uploadEndpoint => '\\$apiBaseUrl/upload';",
      "",
      "  // Cache keys",
      "  String get usersCacheKey => '${1:users}_cache';",
      "  String get authCacheKey => 'auth_cache';",
      "  String get settingsCacheKey => 'settings_cache';",
      "",
      "  // Pagination defaults",
      "  int get defaultPageSize => 20;",
      "  int get maxPageSize => 100;",
      "",
      "  // Validation rules",
      "  int get minNameLength => 2;",
      "  int get maxNameLength => 100;",
      "  int get minPasswordLength => 8;",
      "  int get maxPasswordLength => 128;",
      "",
      "  // File upload limits",
      "  int get maxFileSize => 10 * 1024 * 1024; // 10MB",
      "  List<String> get allowedImageTypes => ['jpg', 'jpeg', 'png', 'gif', 'webp'];",
      "  List<String> get allowedDocumentTypes => ['pdf', 'doc', 'docx', 'txt'];",
      "}",
      "$0"
    ]
  }
}
