{
  "ToJson Method": {
    "prefix": "dart-tojson",
    "description": "Auto-generated toJson method for class serialization",
    "body": [
      "Map<String, dynamic> toJson() {",
      "  return {",
      "    '${1:id}': ${1:id},",
      "    '${2:name}': ${2:name},",
      "    '${3:email}': ${3:email},",
      "    '${4:createdAt}': ${4:createdAt}${5:.toIso8601String()},",
      "    ${6:// Add more fields as needed}",
      "  };",
      "}"
    ]
  },

  "FromJson Factory": {
    "prefix": "dart-fromjson",
    "description": "Auto-generated fromJson factory constructor",
    "body": [
      "factory ${1:ClassName}.fromJson(Map<String, dynamic> json) {",
      "  return ${1:ClassName}(",
      "    ${2:id}: json['${2:id}'] as ${3:String},",
      "    ${4:name}: json['${4:name}'] as ${5:String},",
      "    ${6:email}: json['${6:email}'] as ${7:String},",
      "    ${8:createdAt}: DateTime.parse(json['${8:createdAt}'] as String),",
      "    ${9:// Add more fields as needed}",
      "  );",
      "}"
    ]
  },

  "ToString Method": {
    "prefix": "dart-tostring",
    "description": "Auto-generated toString method with all fields",
    "body": [
      "@override",
      "String toString() {",
      "  return '${1:ClassName}{${2:id}: \\$${2:id}, ${3:name}: \\$${3:name}, ${4:email}: \\$${4:email}, ${5:createdAt}: \\$${5:createdAt}}';",
      "}"
    ]
  },

  "Equals and HashCode": {
    "prefix": "dart-equals",
    "description": "Auto-generated equals and hashCode methods",
    "body": [
      "@override",
      "bool operator ==(Object other) {",
      "  if (identical(this, other)) return true;",
      "",
      "  return other is ${1:ClassName} &&",
      "      other.${2:id} == ${2:id} &&",
      "      other.${3:name} == ${3:name} &&",
      "      other.${4:email} == ${4:email};",
      "}",
      "",
      "@override",
      "int get hashCode {",
      "  return ${2:id}.hashCode ^",
      "      ${3:name}.hashCode ^",
      "      ${4:email}.hashCode;",
      "}"
    ]
  },

  "CopyWith Method": {
    "prefix": "dart-copywith",
    "description": "Auto-generated copyWith method for immutable classes",
    "body": [
      "${1:ClassName} copyWith({",
      "  ${2:String}? ${3:id},",
      "  ${4:String}? ${5:name},",
      "  ${6:String}? ${7:email},",
      "  ${8:DateTime}? ${9:createdAt},",
      "}) {",
      "  return ${1:ClassName}(",
      "    ${3:id}: ${3:id} ?? this.${3:id},",
      "    ${5:name}: ${5:name} ?? this.${5:name},",
      "    ${7:email}: ${7:email} ?? this.${7:email},",
      "    ${9:createdAt}: ${9:createdAt} ?? this.${9:createdAt},",
      "  );",
      "}"
    ]
  },

  "Date Formatter Utility": {
    "prefix": "dart-dateformat",
    "description": "Complete date formatting utility class",
    "body": [
      "import 'package:intl/intl.dart';",
      "",
      "class ${1:DateFormatUtil} {",
      "  static const String _defaultFormat = 'yyyy-MM-dd HH:mm:ss';",
      "  static const String _dateOnlyFormat = 'yyyy-MM-dd';",
      "  static const String _timeOnlyFormat = 'HH:mm:ss';",
      "  static const String _humanReadableFormat = 'MMM dd, yyyy at HH:mm';",
      "",
      "  static String formatDateTime(DateTime dateTime, {String? format}) {",
      "    final formatter = DateFormat(format ?? _defaultFormat);",
      "    return formatter.format(dateTime);",
      "  }",
      "",
      "  static String formatDateOnly(DateTime dateTime) {",
      "    return formatDateTime(dateTime, format: _dateOnlyFormat);",
      "  }",
      "",
      "  static String formatTimeOnly(DateTime dateTime) {",
      "    return formatDateTime(dateTime, format: _timeOnlyFormat);",
      "  }",
      "",
      "  static String formatHumanReadable(DateTime dateTime) {",
      "    return formatDateTime(dateTime, format: _humanReadableFormat);",
      "  }",
      "",
      "  static String timeAgo(DateTime dateTime) {",
      "    final now = DateTime.now();",
      "    final difference = now.difference(dateTime);",
      "",
      "    if (difference.inDays > 365) {",
      "      return '\\${(difference.inDays / 365).floor()} year\\${difference.inDays > 730 ? 's' : ''} ago';",
      "    } else if (difference.inDays > 30) {",
      "      return '\\${(difference.inDays / 30).floor()} month\\${difference.inDays > 60 ? 's' : ''} ago';",
      "    } else if (difference.inDays > 0) {",
      "      return '\\${difference.inDays} day\\${difference.inDays > 1 ? 's' : ''} ago';",
      "    } else if (difference.inHours > 0) {",
      "      return '\\${difference.inHours} hour\\${difference.inHours > 1 ? 's' : ''} ago';",
      "    } else if (difference.inMinutes > 0) {",
      "      return '\\${difference.inMinutes} minute\\${difference.inMinutes > 1 ? 's' : ''} ago';",
      "    } else {",
      "      return 'Just now';",
      "    }",
      "  }",
      "",
      "  static DateTime? parseDateTime(String dateString, {String? format}) {",
      "    try {",
      "      if (format != null) {",
      "        final formatter = DateFormat(format);",
      "        return formatter.parse(dateString);",
      "      }",
      "      return DateTime.parse(dateString);",
      "    } catch (e) {",
      "      return null;",
      "    }",
      "  }",
      "",
      "  static bool isToday(DateTime dateTime) {",
      "    final now = DateTime.now();",
      "    return dateTime.year == now.year &&",
      "        dateTime.month == now.month &&",
      "        dateTime.day == now.day;",
      "  }",
      "",
      "  static bool isYesterday(DateTime dateTime) {",
      "    final yesterday = DateTime.now().subtract(const Duration(days: 1));",
      "    return dateTime.year == yesterday.year &&",
      "        dateTime.month == yesterday.month &&",
      "        dateTime.day == yesterday.day;",
      "  }",
      "}"
    ]
  },

  "String Extensions": {
    "prefix": "dart-string-ext",
    "description": "Useful string extension methods",
    "body": [
      "extension StringExtensions on String {",
      "  String capitalize() {",
      "    if (isEmpty) return this;",
      "    return this[0].toUpperCase() + substring(1).toLowerCase();",
      "  }",
      "",
      "  String capitalizeWords() {",
      "    return split(' ').map((word) => word.capitalize()).join(' ');",
      "  }",
      "",
      "  bool get isEmail {",
      "    return RegExp(r'^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}\\$').hasMatch(this);",
      "  }",
      "",
      "  bool get isPhoneNumber {",
      "    return RegExp(r'^[\\+]?[1-9][\\d]{0,15}\\$').hasMatch(this);",
      "  }",
      "",
      "  bool get isUrl {",
      "    return RegExp(r'^https?:\\/\\/.+').hasMatch(this);",
      "  }",
      "",
      "  String removeSpecialCharacters() {",
      "    return replaceAll(RegExp(r'[^\\w\\s]+'), '');",
      "  }",
      "",
      "  String truncate(int maxLength, {String suffix = '...'}) {",
      "    if (length <= maxLength) return this;",
      "    return substring(0, maxLength - suffix.length) + suffix;",
      "  }",
      "",
      "  String maskEmail() {",
      "    if (!isEmail) return this;",
      "    final parts = split('@');",
      "    final username = parts[0];",
      "    final domain = parts[1];",
      "    ",
      "    if (username.length <= 2) return this;",
      "    ",
      "    final maskedUsername = username[0] + '*' * (username.length - 2) + username[username.length - 1];",
      "    return '\\$maskedUsername@\\$domain';",
      "  }",
      "",
      "  String toSnakeCase() {",
      "    return replaceAllMapped(RegExp(r'[A-Z]'), (match) => '_\\${match.group(0)!.toLowerCase()}').replaceFirst(RegExp(r'^_'), '');",
      "  }",
      "",
      "  String toCamelCase() {",
      "    return split('_').map((word) => word.capitalize()).join('').replaceFirst(RegExp(r'^[A-Z]'), (match) => match.group(0)!.toLowerCase());",
      "  }",
      "}"
    ]
  },

  "Number Extensions": {
    "prefix": "dart-number-ext",
    "description": "Useful number extension methods",
    "body": [
      "extension NumExtensions on num {",
      "  String toCurrency({String symbol = '\\$', int decimalDigits = 2}) {",
      "    return '\\$symbol\\${toStringAsFixed(decimalDigits)}';",
      "  }",
      "",
      "  String toPercentage({int decimalDigits = 1}) {",
      "    return '\\${(this * 100).toStringAsFixed(decimalDigits)}%';",
      "  }",
      "",
      "  String formatWithCommas() {",
      "    return toString().replaceAllMapped(",
      "      RegExp(r'(\\d{1,3})(?=(\\d{3})+(?!\\d))'),",
      "      (Match m) => '\\${m[1]},',",
      "    );",
      "  }",
      "",
      "  bool get isEven => this % 2 == 0;",
      "  bool get isOdd => this % 2 != 0;",
      "",
      "  bool isBetween(num min, num max) => this >= min && this <= max;",
      "",
      "  num clamp(num min, num max) {",
      "    if (this < min) return min;",
      "    if (this > max) return max;",
      "    return this;",
      "  }",
      "}",
      "",
      "extension IntExtensions on int {",
      "  Duration get milliseconds => Duration(milliseconds: this);",
      "  Duration get seconds => Duration(seconds: this);",
      "  Duration get minutes => Duration(minutes: this);",
      "  Duration get hours => Duration(hours: this);",
      "  Duration get days => Duration(days: this);",
      "",
      "  String toOrdinal() {",
      "    if (this >= 11 && this <= 13) return '\\${this}th';",
      "    switch (this % 10) {",
      "      case 1:",
      "        return '\\${this}st';",
      "      case 2:",
      "        return '\\${this}nd';",
      "      case 3:",
      "        return '\\${this}rd';",
      "      default:",
      "        return '\\${this}th';",
      "    }",
      "  }",
      "}"
    ]
  },

  "List Extensions": {
    "prefix": "dart-list-ext",
    "description": "Useful list extension methods",
    "body": [
      "extension ListExtensions<T> on List<T> {",
      "  T? get firstOrNull => isEmpty ? null : first;",
      "  T? get lastOrNull => isEmpty ? null : last;",
      "",
      "  T? elementAtOrNull(int index) {",
      "    if (index < 0 || index >= length) return null;",
      "    return this[index];",
      "  }",
      "",
      "  List<T> distinctBy<R>(R Function(T) selector) {",
      "    final seen = <R>{};",
      "    return where((element) => seen.add(selector(element))).toList();",
      "  }",
      "",
      "  Map<R, List<T>> groupBy<R>(R Function(T) selector) {",
      "    final map = <R, List<T>>{};",
      "    for (final element in this) {",
      "      final key = selector(element);",
      "      map.putIfAbsent(key, () => []).add(element);",
      "    }",
      "    return map;",
      "  }",
      "",
      "  List<T> chunk(int size) {",
      "    final chunks = <List<T>>[];",
      "    for (int i = 0; i < length; i += size) {",
      "      chunks.add(sublist(i, (i + size > length) ? length : i + size));",
      "    }",
      "    return chunks.expand((chunk) => chunk).toList();",
      "  }",
      "",
      "  T? findWhere(bool Function(T) test) {",
      "    try {",
      "      return firstWhere(test);",
      "    } catch (e) {",
      "      return null;",
      "    }",
      "  }",
      "",
      "  bool containsWhere(bool Function(T) test) {",
      "    return any(test);",
      "  }",
      "",
      "  List<T> updateWhere(bool Function(T) test, T Function(T) update) {",
      "    return map((item) => test(item) ? update(item) : item).toList();",
      "  }",
      "",
      "  double averageBy(double Function(T) selector) {",
      "    if (isEmpty) return 0.0;",
      "    return map(selector).reduce((a, b) => a + b) / length;",
      "  }",
      "}"
    ]
  },

  "Map Extensions": {
    "prefix": "dart-map-ext",
    "description": "Useful map extension methods",
    "body": [
      "extension MapExtensions<K, V> on Map<K, V> {",
      "  V? getOrNull(K key) => containsKey(key) ? this[key] : null;",
      "",
      "  V getOrDefault(K key, V defaultValue) => this[key] ?? defaultValue;",
      "",
      "  Map<K, V> whereKeys(bool Function(K) test) {",
      "    return Map.fromEntries(entries.where((entry) => test(entry.key)));",
      "  }",
      "",
      "  Map<K, V> whereValues(bool Function(V) test) {",
      "    return Map.fromEntries(entries.where((entry) => test(entry.value)));",
      "  }",
      "",
      "  Map<K2, V2> mapEntries<K2, V2>(MapEntry<K2, V2> Function(K, V) transform) {",
      "    return Map.fromEntries(entries.map((entry) => transform(entry.key, entry.value)));",
      "  }",
      "",
      "  Map<K, V> merge(Map<K, V> other, {V Function(V, V)? onConflict}) {",
      "    final result = Map<K, V>.from(this);",
      "    other.forEach((key, value) {",
      "      if (result.containsKey(key) && onConflict != null) {",
      "        result[key] = onConflict(result[key] as V, value);",
      "      } else {",
      "        result[key] = value;",
      "      }",
      "    });",
      "    return result;",
      "  }",
      "",
      "  Map<K, V> filterNulls() {",
      "    return Map.fromEntries(entries.where((entry) => entry.value != null));",
      "  }",
      "}"
    ]
  },

  "DateTime Extensions": {
    "prefix": "dart-datetime-ext",
    "description": "Useful DateTime extension methods",
    "body": [
      "extension DateTimeExtensions on DateTime {",
      "  bool get isToday {",
      "    final now = DateTime.now();",
      "    return year == now.year && month == now.month && day == now.day;",
      "  }",
      "",
      "  bool get isYesterday {",
      "    final yesterday = DateTime.now().subtract(const Duration(days: 1));",
      "    return year == yesterday.year && month == yesterday.month && day == yesterday.day;",
      "  }",
      "",
      "  bool get isTomorrow {",
      "    final tomorrow = DateTime.now().add(const Duration(days: 1));",
      "    return year == tomorrow.year && month == tomorrow.month && day == tomorrow.day;",
      "  }",
      "",
      "  bool get isWeekend => weekday == DateTime.saturday || weekday == DateTime.sunday;",
      "",
      "  bool get isWeekday => !isWeekend;",
      "",
      "  DateTime get startOfDay => DateTime(year, month, day);",
      "",
      "  DateTime get endOfDay => DateTime(year, month, day, 23, 59, 59, 999);",
      "",
      "  DateTime get startOfWeek {",
      "    final daysFromMonday = weekday - 1;",
      "    return subtract(Duration(days: daysFromMonday)).startOfDay;",
      "  }",
      "",
      "  DateTime get endOfWeek {",
      "    final daysToSunday = 7 - weekday;",
      "    return add(Duration(days: daysToSunday)).endOfDay;",
      "  }",
      "",
      "  DateTime get startOfMonth => DateTime(year, month, 1);",
      "",
      "  DateTime get endOfMonth => DateTime(year, month + 1, 0, 23, 59, 59, 999);",
      "",
      "  DateTime addWorkingDays(int days) {",
      "    DateTime result = this;",
      "    int addedDays = 0;",
      "",
      "    while (addedDays < days) {",
      "      result = result.add(const Duration(days: 1));",
      "      if (result.isWeekday) {",
      "        addedDays++;",
      "      }",
      "    }",
      "",
      "    return result;",
      "  }",
      "",
      "  String timeAgo() {",
      "    final now = DateTime.now();",
      "    final difference = now.difference(this);",
      "",
      "    if (difference.inDays > 365) {",
      "      return '\\${(difference.inDays / 365).floor()} year\\${difference.inDays > 730 ? 's' : ''} ago';",
      "    } else if (difference.inDays > 30) {",
      "      return '\\${(difference.inDays / 30).floor()} month\\${difference.inDays > 60 ? 's' : ''} ago';",
      "    } else if (difference.inDays > 0) {",
      "      return '\\${difference.inDays} day\\${difference.inDays > 1 ? 's' : ''} ago';",
      "    } else if (difference.inHours > 0) {",
      "      return '\\${difference.inHours} hour\\${difference.inHours > 1 ? 's' : ''} ago';",
      "    } else if (difference.inMinutes > 0) {",
      "      return '\\${difference.inMinutes} minute\\${difference.inMinutes > 1 ? 's' : ''} ago';",
      "    } else {",
      "      return 'Just now';",
      "    }",
      "  }",
      "",
      "  int get age {",
      "    final now = DateTime.now();",
      "    int age = now.year - year;",
      "    if (now.month < month || (now.month == month && now.day < day)) {",
      "      age--;",
      "    }",
      "    return age;",
      "  }",
      "}"
    ]
  },

  "Validation Utilities": {
    "prefix": "dart-validators",
    "description": "Common validation utility methods",
    "body": [
      "class ${1:ValidationUtils} {",
      "  static bool isEmail(String email) {",
      "    return RegExp(r'^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}\\$').hasMatch(email);",
      "  }",
      "",
      "  static bool isPhoneNumber(String phone) {",
      "    return RegExp(r'^[\\+]?[1-9][\\d]{0,15}\\$').hasMatch(phone);",
      "  }",
      "",
      "  static bool isUrl(String url) {",
      "    return RegExp(r'^https?:\\/\\/.+').hasMatch(url);",
      "  }",
      "",
      "  static bool isStrongPassword(String password) {",
      "    // At least 8 characters, 1 uppercase, 1 lowercase, 1 number, 1 special char",
      "    return RegExp(r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@\\$!%*?&])[A-Za-z\\d@\\$!%*?&]{8,}\\$').hasMatch(password);",
      "  }",
      "",
      "  static bool isCreditCard(String cardNumber) {",
      "    // Remove spaces and dashes",
      "    final cleaned = cardNumber.replaceAll(RegExp(r'[\\s-]'), '');",
      "    ",
      "    // Check if it's all digits and proper length",
      "    if (!RegExp(r'^\\d{13,19}\\$').hasMatch(cleaned)) return false;",
      "    ",
      "    // Luhn algorithm",
      "    int sum = 0;",
      "    bool alternate = false;",
      "    ",
      "    for (int i = cleaned.length - 1; i >= 0; i--) {",
      "      int digit = int.parse(cleaned[i]);",
      "      ",
      "      if (alternate) {",
      "        digit *= 2;",
      "        if (digit > 9) digit -= 9;",
      "      }",
      "      ",
      "      sum += digit;",
      "      alternate = !alternate;",
      "    }",
      "    ",
      "    return sum % 10 == 0;",
      "  }",
      "",
      "  static bool isNumeric(String str) {",
      "    return double.tryParse(str) != null;",
      "  }",
      "",
      "  static bool isAlphaNumeric(String str) {",
      "    return RegExp(r'^[a-zA-Z0-9]+\\$').hasMatch(str);",
      "  }",
      "",
      "  static bool isValidAge(int age, {int minAge = 0, int maxAge = 150}) {",
      "    return age >= minAge && age <= maxAge;",
      "  }",
      "",
      "  static bool isValidDateOfBirth(DateTime dateOfBirth) {",
      "    final now = DateTime.now();",
      "    return dateOfBirth.isBefore(now) && dateOfBirth.isAfter(DateTime(1900));",
      "  }",
      "",
      "  static String? validateRequired(String? value, {String fieldName = 'Field'}) {",
      "    if (value == null || value.trim().isEmpty) {",
      "      return '\\$fieldName is required';",
      "    }",
      "    return null;",
      "  }",
      "",
      "  static String? validateEmail(String? value) {",
      "    if (value == null || value.isEmpty) return 'Email is required';",
      "    if (!isEmail(value)) return 'Please enter a valid email';",
      "    return null;",
      "  }",
      "",
      "  static String? validatePassword(String? value) {",
      "    if (value == null || value.isEmpty) return 'Password is required';",
      "    if (value.length < 8) return 'Password must be at least 8 characters';",
      "    if (!isStrongPassword(value)) {",
      "      return 'Password must contain uppercase, lowercase, number and special character';",
      "    }",
      "    return null;",
      "  }",
      "",
      "  static String? validateMinLength(String? value, int minLength, {String fieldName = 'Field'}) {",
      "    if (value == null || value.length < minLength) {",
      "      return '\\$fieldName must be at least \\$minLength characters';",
      "    }",
      "    return null;",
      "  }",
      "",
      "  static String? validateMaxLength(String? value, int maxLength, {String fieldName = 'Field'}) {",
      "    if (value != null && value.length > maxLength) {",
      "      return '\\$fieldName must not exceed \\$maxLength characters';",
      "    }",
      "    return null;",
      "  }",
      "}"
    ]
  },

  "Error Handling Utility": {
    "prefix": "dart-error-handler",
    "description": "Comprehensive error handling utility",
    "body": [
      "import 'dart:developer' as developer;",
      "",
      "class ${1:ErrorHandler} {",
      "  static void logError(dynamic error, {StackTrace? stackTrace, String? context}) {",
      "    developer.log(",
      "      'Error: \\$error',",
      "      error: error,",
      "      stackTrace: stackTrace,",
      "      name: context ?? 'ErrorHandler',",
      "    );",
      "  }",
      "",
      "  static String getErrorMessage(dynamic error) {",
      "    if (error is Exception) {",
      "      return error.toString().replaceFirst('Exception: ', '');",
      "    }",
      "    return error.toString();",
      "  }",
      "",
      "  static T? handleError<T>(T Function() operation, {T? fallback, bool logError = true}) {",
      "    try {",
      "      return operation();",
      "    } catch (error, stackTrace) {",
      "      if (logError) {",
      "        ErrorHandler.logError(error, stackTrace: stackTrace);",
      "      }",
      "      return fallback;",
      "    }",
      "  }",
      "",
      "  static Future<T?> handleAsyncError<T>(",
      "    Future<T> Function() operation, {",
      "    T? fallback,",
      "    bool logError = true,",
      "  }) async {",
      "    try {",
      "      return await operation();",
      "    } catch (error, stackTrace) {",
      "      if (logError) {",
      "        ErrorHandler.logError(error, stackTrace: stackTrace);",
      "      }",
      "      return fallback;",
      "    }",
      "  }",
      "",
      "  static bool isNetworkError(dynamic error) {",
      "    final errorMessage = error.toString().toLowerCase();",
      "    return errorMessage.contains('socket') ||",
      "        errorMessage.contains('network') ||",
      "        errorMessage.contains('connection') ||",
      "        errorMessage.contains('timeout') ||",
      "        errorMessage.contains('unreachable');",
      "  }",
      "",
      "  static String getUserFriendlyMessage(dynamic error) {",
      "    if (isNetworkError(error)) {",
      "      return 'Network connection error. Please check your internet connection.';",
      "    }",
      "    ",
      "    final errorMessage = error.toString().toLowerCase();",
      "    ",
      "    if (errorMessage.contains('timeout')) {",
      "      return 'Request timed out. Please try again.';",
      "    }",
      "    ",
      "    if (errorMessage.contains('unauthorized') || errorMessage.contains('401')) {",
      "      return 'You are not authorized to perform this action.';",
      "    }",
      "    ",
      "    if (errorMessage.contains('forbidden') || errorMessage.contains('403')) {",
      "      return 'Access forbidden. You do not have permission.';",
      "    }",
      "    ",
      "    if (errorMessage.contains('not found') || errorMessage.contains('404')) {",
      "      return 'The requested resource was not found.';",
      "    }",
      "    ",
      "    if (errorMessage.contains('server') || errorMessage.contains('500')) {",
      "      return 'Server error. Please try again later.';",
      "    }",
      "    ",
      "    return 'An unexpected error occurred. Please try again.';",
      "  }",
      "}"
    ]
  },

  "Logger Utility": {
    "prefix": "dart-logger",
    "description": "Comprehensive logging utility with levels",
    "body": [
      "import 'dart:developer' as developer;",
      "",
      "enum ${1:LogLevel} { debug, info, warning, error, fatal }",
      "",
      "class ${2:Logger} {",
      "  static const String _name = '${3:MyApp}';",
      "  static ${1:LogLevel} _currentLevel = ${1:LogLevel}.debug;",
      "",
      "  static void setLevel(${1:LogLevel} level) {",
      "    _currentLevel = level;",
      "  }",
      "",
      "  static void debug(String message, {String? tag, dynamic data}) {",
      "    if (_shouldLog(${1:LogLevel}.debug)) {",
      "      _log(${1:LogLevel}.debug, message, tag: tag, data: data);",
      "    }",
      "  }",
      "",
      "  static void info(String message, {String? tag, dynamic data}) {",
      "    if (_shouldLog(${1:LogLevel}.info)) {",
      "      _log(${1:LogLevel}.info, message, tag: tag, data: data);",
      "    }",
      "  }",
      "",
      "  static void warning(String message, {String? tag, dynamic data}) {",
      "    if (_shouldLog(${1:LogLevel}.warning)) {",
      "      _log(${1:LogLevel}.warning, message, tag: tag, data: data);",
      "    }",
      "  }",
      "",
      "  static void error(String message, {String? tag, dynamic error, StackTrace? stackTrace}) {",
      "    if (_shouldLog(${1:LogLevel}.error)) {",
      "      _log(${1:LogLevel}.error, message, tag: tag, data: error, stackTrace: stackTrace);",
      "    }",
      "  }",
      "",
      "  static void fatal(String message, {String? tag, dynamic error, StackTrace? stackTrace}) {",
      "    if (_shouldLog(${1:LogLevel}.fatal)) {",
      "      _log(${1:LogLevel}.fatal, message, tag: tag, data: error, stackTrace: stackTrace);",
      "    }",
      "  }",
      "",
      "  static bool _shouldLog(${1:LogLevel} level) {",
      "    return level.index >= _currentLevel.index;",
      "  }",
      "",
      "  static void _log(",
      "    ${1:LogLevel} level,",
      "    String message, {",
      "    String? tag,",
      "    dynamic data,",
      "    StackTrace? stackTrace,",
      "  }) {",
      "    final timestamp = DateTime.now().toIso8601String();",
      "    final levelName = level.name.toUpperCase();",
      "    final tagName = tag ?? _name;",
      "    ",
      "    String logMessage = '[\\$timestamp] [\\$levelName] [\\$tagName] \\$message';",
      "    ",
      "    if (data != null) {",
      "      logMessage += '\\nData: \\$data';",
      "    }",
      "",
      "    developer.log(",
      "      logMessage,",
      "      name: tagName,",
      "      error: level == ${1:LogLevel}.error || level == ${1:LogLevel}.fatal ? data : null,",
      "      stackTrace: stackTrace,",
      "      level: _getDeveloperLogLevel(level),",
      "    );",
      "  }",
      "",
      "  static int _getDeveloperLogLevel(${1:LogLevel} level) {",
      "    switch (level) {",
      "      case ${1:LogLevel}.debug:",
      "        return 500;",
      "      case ${1:LogLevel}.info:",
      "        return 800;",
      "      case ${1:LogLevel}.warning:",
      "        return 900;",
      "      case ${1:LogLevel}.error:",
      "        return 1000;",
      "      case ${1:LogLevel}.fatal:",
      "        return 1200;",
      "    }",
      "  }",
      "}"
    ]
  }
}
