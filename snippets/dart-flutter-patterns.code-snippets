{
  "Mixin for Validation": {
    "prefix": "dart-validation-mixin",
    "description": "Validation mixin for forms and input fields",
    "body": [
      "mixin ${1:ValidationMixin} {",
      "  String? validateEmail(String? value) {",
      "    if (value == null || value.isEmpty) {",
      "      return 'Email is required';",
      "    }",
      "    final emailRegex = RegExp(r'^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}\\$');",
      "    if (!emailRegex.hasMatch(value)) {",
      "      return 'Please enter a valid email';",
      "    }",
      "    return null;",
      "  }",
      "",
      "  String? validatePassword(String? value) {",
      "    if (value == null || value.isEmpty) {",
      "      return 'Password is required';",
      "    }",
      "    if (value.length < 8) {",
      "      return 'Password must be at least 8 characters';",
      "    }",
      "    return null;",
      "  }",
      "",
      "  String? validateRequired(String? value, {String fieldName = 'Field'}) {",
      "    if (value == null || value.trim().isEmpty) {",
      "      return '\\$fieldName is required';",
      "    }",
      "    return null;",
      "  }",
      "",
      "  String? validateMinLength(String? value, int minLength, {String fieldName = 'Field'}) {",
      "    if (value == null || value.length < minLength) {",
      "      return '\\$fieldName must be at least \\$minLength characters';",
      "    }",
      "    return null;",
      "  }",
      "",
      "  String? validatePhoneNumber(String? value) {",
      "    if (value == null || value.isEmpty) {",
      "      return 'Phone number is required';",
      "    }",
      "    final phoneRegex = RegExp(r'^[\\+]?[1-9][\\d]{0,15}\\$');",
      "    if (!phoneRegex.hasMatch(value)) {",
      "      return 'Please enter a valid phone number';",
      "    }",
      "    return null;",
      "  }",
      "}"
    ]
  },

  "Result Pattern": {
    "prefix": "dart-result",
    "description": "Result pattern for error handling without exceptions",
    "body": [
      "abstract class ${1:Result}<T> {",
      "  const ${1:Result}();",
      "  ",
      "  bool get isSuccess => this is ${2:Success}<T>;",
      "  bool get isFailure => this is ${3:Failure}<T>;",
      "  ",
      "  T get data {",
      "    if (this is ${2:Success}<T>) {",
      "      return (this as ${2:Success}<T>).value;",
      "    }",
      "    throw StateError('Cannot get data from a failure result');",
      "  }",
      "  ",
      "  String get error {",
      "    if (this is ${3:Failure}<T>) {",
      "      return (this as ${3:Failure}<T>).message;",
      "    }",
      "    throw StateError('Cannot get error from a success result');",
      "  }",
      "  ",
      "  R fold<R>(R Function(T) onSuccess, R Function(String) onFailure) {",
      "    if (this is ${2:Success}<T>) {",
      "      return onSuccess((this as ${2:Success}<T>).value);",
      "    } else {",
      "      return onFailure((this as ${3:Failure}<T>).message);",
      "    }",
      "  }",
      "  ",
      "  ${1:Result}<R> map<R>(R Function(T) transform) {",
      "    if (this is ${2:Success}<T>) {",
      "      try {",
      "        return ${2:Success}(transform((this as ${2:Success}<T>).value));",
      "      } catch (e) {",
      "        return ${3:Failure}(e.toString());",
      "      }",
      "    } else {",
      "      return ${3:Failure}((this as ${3:Failure}<T>).message);",
      "    }",
      "  }",
      "  ",
      "  static ${1:Result}<T> success<T>(T value) => ${2:Success}(value);",
      "  static ${1:Result}<T> failure<T>(String message) => ${3:Failure}(message);",
      "}",
      "",
      "class ${2:Success}<T> extends ${1:Result}<T> {",
      "  final T value;",
      "  const ${2:Success}(this.value);",
      "  ",
      "  @override",
      "  String toString() => '${2:Success}(\\$value)';",
      "  ",
      "  @override",
      "  bool operator ==(Object other) {",
      "    return other is ${2:Success}<T> && other.value == value;",
      "  }",
      "  ",
      "  @override",
      "  int get hashCode => value.hashCode;",
      "}",
      "",
      "class ${3:Failure}<T> extends ${1:Result}<T> {",
      "  final String message;",
      "  const ${3:Failure}(this.message);",
      "  ",
      "  @override",
      "  String toString() => '${3:Failure}(\\$message)';",
      "  ",
      "  @override",
      "  bool operator ==(Object other) {",
      "    return other is ${3:Failure}<T> && other.message == message;",
      "  }",
      "  ",
      "  @override",
      "  int get hashCode => message.hashCode;",
      "}"
    ]
  },

  "Cache Manager": {
    "prefix": "dart-cache",
    "description": "Simple in-memory cache manager with expiration",
    "body": [
      "class ${1:CacheItem}<T> {",
      "  final T value;",
      "  final DateTime expiry;",
      "  ",
      "  ${1:CacheItem}(this.value, this.expiry);",
      "  ",
      "  bool get isExpired => DateTime.now().isAfter(expiry);",
      "}",
      "",
      "class ${2:CacheManager} {",
      "  static final ${2:CacheManager} _instance = ${2:CacheManager}._internal();",
      "  factory ${2:CacheManager}() => _instance;",
      "  ${2:CacheManager}._internal();",
      "  ",
      "  final Map<String, ${1:CacheItem}> _cache = {};",
      "  ",
      "  void put<T>(String key, T value, {Duration? ttl}) {",
      "    final expiry = DateTime.now().add(ttl ?? const Duration(minutes: 10));",
      "    _cache[key] = ${1:CacheItem}(value, expiry);",
      "  }",
      "  ",
      "  T? get<T>(String key) {",
      "    final item = _cache[key];",
      "    if (item == null) return null;",
      "    ",
      "    if (item.isExpired) {",
      "      _cache.remove(key);",
      "      return null;",
      "    }",
      "    ",
      "    return item.value as T?;",
      "  }",
      "  ",
      "  bool contains(String key) {",
      "    final item = _cache[key];",
      "    if (item == null) return false;",
      "    ",
      "    if (item.isExpired) {",
      "      _cache.remove(key);",
      "      return false;",
      "    }",
      "    ",
      "    return true;",
      "  }",
      "  ",
      "  void remove(String key) {",
      "    _cache.remove(key);",
      "  }",
      "  ",
      "  void clear() {",
      "    _cache.clear();",
      "  }",
      "  ",
      "  void clearExpired() {",
      "    final now = DateTime.now();",
      "    _cache.removeWhere((key, item) => now.isAfter(item.expiry));",
      "  }",
      "  ",
      "  int get size => _cache.length;",
      "  ",
      "  List<String> get keys => _cache.keys.toList();",
      "}"
    ]
  },

  "Debouncer Utility": {
    "prefix": "dart-debouncer",
    "description": "Debouncer for handling rapid successive calls",
    "body": [
      "import 'dart:async';",
      "",
      "class ${1:Debouncer} {",
      "  final Duration delay;",
      "  Timer? _timer;",
      "  ",
      "  ${1:Debouncer}({this.delay = const Duration(milliseconds: 500)});",
      "  ",
      "  void call(void Function() action) {",
      "    _timer?.cancel();",
      "    _timer = Timer(delay, action);",
      "  }",
      "  ",
      "  void cancel() {",
      "    _timer?.cancel();",
      "  }",
      "  ",
      "  bool get isActive => _timer?.isActive ?? false;",
      "}",
      "",
      "class ${2:Throttler} {",
      "  final Duration delay;",
      "  DateTime? _lastActionTime;",
      "  ",
      "  ${2:Throttler}({this.delay = const Duration(milliseconds: 500)});",
      "  ",
      "  bool call(void Function() action) {",
      "    final now = DateTime.now();",
      "    ",
      "    if (_lastActionTime == null || now.difference(_lastActionTime!) >= delay) {",
      "      _lastActionTime = now;",
      "      action();",
      "      return true;",
      "    }",
      "    ",
      "    return false;",
      "  }",
      "  ",
      "  void reset() {",
      "    _lastActionTime = null;",
      "  }",
      "}"
    ]
  },

  "Event Bus": {
    "prefix": "dart-eventbus",
    "description": "Simple event bus for decoupled communication",
    "body": [
      "import 'dart:async';",
      "",
      "class ${1:EventBus} {",
      "  static final ${1:EventBus} _instance = ${1:EventBus}._internal();",
      "  factory ${1:EventBus}() => _instance;",
      "  ${1:EventBus}._internal();",
      "  ",
      "  final Map<Type, List<Function>> _listeners = {};",
      "  final StreamController<dynamic> _controller = StreamController.broadcast();",
      "  ",
      "  Stream<T> on<T>() {",
      "    return _controller.stream.where((event) => event is T).cast<T>();",
      "  }",
      "  ",
      "  void emit<T>(T event) {",
      "    _controller.add(event);",
      "  }",
      "  ",
      "  StreamSubscription<T> listen<T>(void Function(T) onData) {",
      "    return on<T>().listen(onData);",
      "  }",
      "  ",
      "  void dispose() {",
      "    _listeners.clear();",
      "    _controller.close();",
      "  }",
      "}",
      "",
      "// Example event classes",
      "class ${2:UserLoggedIn} {",
      "  final String userId;",
      "  final String username;",
      "  ",
      "  ${2:UserLoggedIn}({required this.userId, required this.username});",
      "}",
      "",
      "class ${3:DataUpdated} {",
      "  final String dataType;",
      "  final dynamic data;",
      "  ",
      "  ${3:DataUpdated}({required this.dataType, this.data});",
      "}"
    ]
  },

  "Retry Mechanism": {
    "prefix": "dart-retry",
    "description": "Retry mechanism for failed operations",
    "body": [
      "import 'dart:async';",
      "import 'dart:math';",
      "",
      "class ${1:RetryConfig} {",
      "  final int maxAttempts;",
      "  final Duration initialDelay;",
      "  final double backoffMultiplier;",
      "  final Duration maxDelay;",
      "  final bool Function(dynamic)? retryIf;",
      "  ",
      "  const ${1:RetryConfig}({",
      "    this.maxAttempts = 3,",
      "    this.initialDelay = const Duration(seconds: 1),",
      "    this.backoffMultiplier = 2.0,",
      "    this.maxDelay = const Duration(seconds: 30),",
      "    this.retryIf,",
      "  });",
      "}",
      "",
      "class ${2:RetryUtil} {",
      "  static Future<T> retry<T>(",
      "    Future<T> Function() operation, {",
      "    ${1:RetryConfig}? config,",
      "  }) async {",
      "    final retryConfig = config ?? const ${1:RetryConfig}();",
      "    int attempt = 0;",
      "    Duration delay = retryConfig.initialDelay;",
      "    ",
      "    while (attempt < retryConfig.maxAttempts) {",
      "      try {",
      "        return await operation();",
      "      } catch (error) {",
      "        attempt++;",
      "        ",
      "        // Check if we should retry this error",
      "        if (retryConfig.retryIf != null && !retryConfig.retryIf!(error)) {",
      "          rethrow;",
      "        }",
      "        ",
      "        // If this was the last attempt, rethrow the error",
      "        if (attempt >= retryConfig.maxAttempts) {",
      "          rethrow;",
      "        }",
      "        ",
      "        // Wait before retrying",
      "        await Future.delayed(delay);",
      "        ",
      "        // Calculate next delay with exponential backoff",
      "        delay = Duration(",
      "          milliseconds: min(",
      "            (delay.inMilliseconds * retryConfig.backoffMultiplier).round(),",
      "            retryConfig.maxDelay.inMilliseconds,",
      "          ),",
      "        );",
      "      }",
      "    }",
      "    ",
      "    throw StateError('This should never be reached');",
      "  }",
      "  ",
      "  static Future<T?> retryWithFallback<T>(",
      "    Future<T> Function() operation, {",
      "    ${1:RetryConfig}? config,",
      "    T? fallback,",
      "  }) async {",
      "    try {",
      "      return await retry(operation, config: config);",
      "    } catch (e) {",
      "      return fallback;",
      "    }",
      "  }",
      "}"
    ]
  },

  "API Response Model": {
    "prefix": "dart-api-response",
    "description": "Generic API response model with error handling",
    "body": [
      "class ${1:ApiResponse}<T> {",
      "  final bool success;",
      "  final T? data;",
      "  final String? message;",
      "  final String? errorCode;",
      "  final int? statusCode;",
      "  final Map<String, dynamic>? metadata;",
      "  ",
      "  const ${1:ApiResponse}({",
      "    required this.success,",
      "    this.data,",
      "    this.message,",
      "    this.errorCode,",
      "    this.statusCode,",
      "    this.metadata,",
      "  });",
      "  ",
      "  factory ${1:ApiResponse}.success(T data, {String? message, Map<String, dynamic>? metadata}) {",
      "    return ${1:ApiResponse}(",
      "      success: true,",
      "      data: data,",
      "      message: message,",
      "      metadata: metadata,",
      "    );",
      "  }",
      "  ",
      "  factory ${1:ApiResponse}.error({",
      "    required String message,",
      "    String? errorCode,",
      "    int? statusCode,",
      "    Map<String, dynamic>? metadata,",
      "  }) {",
      "    return ${1:ApiResponse}(",
      "      success: false,",
      "      message: message,",
      "      errorCode: errorCode,",
      "      statusCode: statusCode,",
      "      metadata: metadata,",
      "    );",
      "  }",
      "  ",
      "  factory ${1:ApiResponse}.fromJson(",
      "    Map<String, dynamic> json,",
      "    T Function(dynamic) fromJsonT,",
      "  ) {",
      "    return ${1:ApiResponse}(",
      "      success: json['success'] ?? false,",
      "      data: json['data'] != null ? fromJsonT(json['data']) : null,",
      "      message: json['message'],",
      "      errorCode: json['errorCode'] ?? json['error_code'],",
      "      statusCode: json['statusCode'] ?? json['status_code'],",
      "      metadata: json['metadata'],",
      "    );",
      "  }",
      "  ",
      "  Map<String, dynamic> toJson(Map<String, dynamic> Function(T)? toJsonT) {",
      "    return {",
      "      'success': success,",
      "      'data': data != null && toJsonT != null ? toJsonT(data as T) : data,",
      "      'message': message,",
      "      'errorCode': errorCode,",
      "      'statusCode': statusCode,",
      "      'metadata': metadata,",
      "    };",
      "  }",
      "  ",
      "  bool get isSuccess => success && data != null;",
      "  bool get isError => !success;",
      "  ",
      "  T get requireData {",
      "    if (data == null) {",
      "      throw StateError('Data is null in API response');",
      "    }",
      "    return data as T;",
      "  }",
      "  ",
      "  @override",
      "  String toString() {",
      "    return '${1:ApiResponse}(success: \\$success, data: \\$data, message: \\$message)';",
      "  }",
      "}"
    ]
  },

  "Preferences Manager": {
    "prefix": "dart-preferences",
    "description": "SharedPreferences wrapper with type safety",
    "body": [
      "import 'package:shared_preferences/shared_preferences.dart';",
      "",
      "class ${1:PreferencesManager} {",
      "  static SharedPreferences? _prefs;",
      "  ",
      "  static Future<void> initialize() async {",
      "    _prefs = await SharedPreferences.getInstance();",
      "  }",
      "  ",
      "  static SharedPreferences get _instance {",
      "    if (_prefs == null) {",
      "      throw StateError('PreferencesManager not initialized. Call initialize() first.');",
      "    }",
      "    return _prefs!;",
      "  }",
      "  ",
      "  // String methods",
      "  static Future<bool> setString(String key, String value) {",
      "    return _instance.setString(key, value);",
      "  }",
      "  ",
      "  static String? getString(String key, {String? defaultValue}) {",
      "    return _instance.getString(key) ?? defaultValue;",
      "  }",
      "  ",
      "  // Integer methods",
      "  static Future<bool> setInt(String key, int value) {",
      "    return _instance.setInt(key, value);",
      "  }",
      "  ",
      "  static int getInt(String key, {int defaultValue = 0}) {",
      "    return _instance.getInt(key) ?? defaultValue;",
      "  }",
      "  ",
      "  // Boolean methods",
      "  static Future<bool> setBool(String key, bool value) {",
      "    return _instance.setBool(key, value);",
      "  }",
      "  ",
      "  static bool getBool(String key, {bool defaultValue = false}) {",
      "    return _instance.getBool(key) ?? defaultValue;",
      "  }",
      "  ",
      "  // Double methods",
      "  static Future<bool> setDouble(String key, double value) {",
      "    return _instance.setDouble(key, value);",
      "  }",
      "  ",
      "  static double getDouble(String key, {double defaultValue = 0.0}) {",
      "    return _instance.getDouble(key) ?? defaultValue;",
      "  }",
      "  ",
      "  // List<String> methods",
      "  static Future<bool> setStringList(String key, List<String> value) {",
      "    return _instance.setStringList(key, value);",
      "  }",
      "  ",
      "  static List<String> getStringList(String key, {List<String>? defaultValue}) {",
      "    return _instance.getStringList(key) ?? defaultValue ?? [];",
      "  }",
      "  ",
      "  // Generic object methods (JSON)",
      "  static Future<bool> setObject<T>(String key, T object, Map<String, dynamic> Function(T) toJson) {",
      "    final jsonString = jsonEncode(toJson(object));",
      "    return setString(key, jsonString);",
      "  }",
      "  ",
      "  static T? getObject<T>(String key, T Function(Map<String, dynamic>) fromJson) {",
      "    final jsonString = getString(key);",
      "    if (jsonString == null) return null;",
      "    ",
      "    try {",
      "      final jsonMap = jsonDecode(jsonString) as Map<String, dynamic>;",
      "      return fromJson(jsonMap);",
      "    } catch (e) {",
      "      return null;",
      "    }",
      "  }",
      "  ",
      "  // Utility methods",
      "  static Future<bool> remove(String key) {",
      "    return _instance.remove(key);",
      "  }",
      "  ",
      "  static Future<bool> clear() {",
      "    return _instance.clear();",
      "  }",
      "  ",
      "  static bool containsKey(String key) {",
      "    return _instance.containsKey(key);",
      "  }",
      "  ",
      "  static Set<String> getKeys() {",
      "    return _instance.getKeys();",
      "  }",
      "}"
    ]
  }
}
