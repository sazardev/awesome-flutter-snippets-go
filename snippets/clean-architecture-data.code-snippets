{
  "DTO Model": {
    "prefix": "clean-dto",
    "description": "Complete DTO with JSON serialization and validation",
    "body": [
      "import 'package:freezed_annotation/freezed_annotation.dart';",
      "",
      "part '${1:user}_dto.freezed.dart';",
      "part '${1:user}_dto.g.dart';",
      "",
      "@freezed",
      "class ${2:User}Dto with _\\$${2:User}Dto {",
      "  const factory ${2:User}Dto({",
      "    required String id,",
      "    required String name,",
      "    required String email,",
      "    @JsonKey(name: 'created_at') required String createdAt,",
      "    @JsonKey(name: 'updated_at') String? updatedAt,",
      "    @JsonKey(name: 'is_active') @Default(true) bool isActive,",
      "    @JsonKey(name: 'profile_image_url') String? profileImageUrl,",
      "    @JsonKey(name: 'phone_number') String? phoneNumber,",
      "    @JsonKey(name: 'date_of_birth') String? dateOfBirth,",
      "    @Default(<String, dynamic>{}) Map<String, dynamic> metadata,",
      "    @JsonKey(name: 'last_login_at') String? lastLoginAt,",
      "    @Default(<String>[]) List<String> roles,",
      "    @JsonKey(name: 'email_verified') @Default(false) bool emailVerified,",
      "    @JsonKey(name: 'phone_verified') @Default(false) bool phoneVerified,",
      "  }) = _${2:User}Dto;",
      "",
      "  factory ${2:User}Dto.fromJson(Map<String, dynamic> json) =>",
      "      _\\$${2:User}DtoFromJson(json);",
      "",
      "  // Custom factory constructors",
      "  factory ${2:User}Dto.empty() => ${2:User}Dto(",
      "        id: '',",
      "        name: '',",
      "        email: '',",
      "        createdAt: DateTime.now().toIso8601String(),",
      "      );",
      "",
      "  factory ${2:User}Dto.minimal({",
      "    required String id,",
      "    required String name,",
      "    required String email,",
      "  }) =>",
      "      ${2:User}Dto(",
      "        id: id,",
      "        name: name,",
      "        email: email,",
      "        createdAt: DateTime.now().toIso8601String(),",
      "      );",
      "}",
      "",
      "// Extension methods for additional functionality",
      "extension ${2:User}DtoX on ${2:User}Dto {",
      "  bool get hasProfileImage => profileImageUrl?.isNotEmpty == true;",
      "",
      "  bool get hasPhoneNumber => phoneNumber?.isNotEmpty == true;",
      "",
      "  bool get isFullyVerified => emailVerified && phoneVerified;",
      "",
      "  bool get hasRecentActivity {",
      "    if (lastLoginAt == null) return false;",
      "    final lastLogin = DateTime.tryParse(lastLoginAt!);",
      "    if (lastLogin == null) return false;",
      "    return DateTime.now().difference(lastLogin).inDays <= 30;",
      "  }",
      "",
      "  DateTime? get parsedCreatedAt => DateTime.tryParse(createdAt);",
      "",
      "  DateTime? get parsedUpdatedAt {",
      "    if (updatedAt == null) return null;",
      "    return DateTime.tryParse(updatedAt!);",
      "  }",
      "",
      "  DateTime? get parsedLastLoginAt {",
      "    if (lastLoginAt == null) return null;",
      "    return DateTime.tryParse(lastLoginAt!);",
      "  }",
      "",
      "  DateTime? get parsedDateOfBirth {",
      "    if (dateOfBirth == null) return null;",
      "    return DateTime.tryParse(dateOfBirth!);",
      "  }",
      "",
      "  int? get age {",
      "    final birthDate = parsedDateOfBirth;",
      "    if (birthDate == null) return null;",
      "    final now = DateTime.now();",
      "    int age = now.year - birthDate.year;",
      "    if (now.month < birthDate.month ||",
      "        (now.month == birthDate.month && now.day < birthDate.day)) {",
      "      age--;",
      "    }",
      "    return age;",
      "  }",
      "",
      "  bool hasRole(String role) => roles.contains(role);",
      "",
      "  bool get isAdmin => hasRole('admin');",
      "",
      "  bool get isModerator => hasRole('moderator');",
      "",
      "  Map<String, dynamic> toMinimalJson() => {",
      "        'id': id,",
      "        'name': name,",
      "        'email': email,",
      "      };",
      "}",
      "$0"
    ]
  },

  "Entity Mapper": {
    "prefix": "clean-mapper",
    "description": "Complete mapper between DTOs and Entities with error handling",
    "body": [
      "import 'package:dartz/dartz.dart';",
      "",
      "import '../../domain/entities/${1:user}.dart';",
      "import '../../domain/failures/${2:domain}_failure.dart';",
      "import '../models/${1:user}_dto.dart';",
      "",
      "class ${3:User}Mapper {",
      "  // DTO to Entity conversion",
      "  static Either<${2:Domain}Failure, ${1:User}> dtoToEntity(${3:User}Dto dto) {",
      "    try {",
      "      // Validate required fields",
      "      if (dto.id.trim().isEmpty) {",
      "        return left(const ${2:Domain}Failure.parsingError('Invalid ID in DTO'));",
      "      }",
      "",
      "      if (dto.name.trim().isEmpty) {",
      "        return left(const ${2:Domain}Failure.parsingError('Invalid name in DTO'));",
      "      }",
      "",
      "      if (dto.email.trim().isEmpty) {",
      "        return left(const ${2:Domain}Failure.parsingError('Invalid email in DTO'));",
      "      }",
      "",
      "      // Parse dates with validation",
      "      final createdAt = DateTime.tryParse(dto.createdAt);",
      "      if (createdAt == null) {",
      "        return left(const ${2:Domain}Failure.parsingError(",
      "          'Invalid createdAt date format',",
      "        ));",
      "      }",
      "",
      "      DateTime? updatedAt;",
      "      if (dto.updatedAt != null) {",
      "        updatedAt = DateTime.tryParse(dto.updatedAt!);",
      "        if (updatedAt == null) {",
      "          return left(const ${2:Domain}Failure.parsingError(",
      "            'Invalid updatedAt date format',",
      "          ));",
      "        }",
      "      }",
      "",
      "      // Create entity",
      "      final entity = ${1:User}(",
      "        id: dto.id.trim(),",
      "        name: dto.name.trim(),",
      "        email: dto.email.trim().toLowerCase(),",
      "        createdAt: createdAt,",
      "        updatedAt: updatedAt,",
      "      );",
      "",
      "      return right(entity);",
      "    } catch (e) {",
      "      return left(${2:Domain}Failure.parsingError(",
      "        'Failed to parse ${3:User}Dto: \\$e',",
      "      ));",
      "    }",
      "  }",
      "",
      "  // Entity to DTO conversion",
      "  static ${3:User}Dto entityToDto(${1:User} entity) {",
      "    return ${3:User}Dto(",
      "      id: entity.id,",
      "      name: entity.name,",
      "      email: entity.email,",
      "      createdAt: entity.createdAt.toIso8601String(),",
      "      updatedAt: entity.updatedAt?.toIso8601String(),",
      "    );",
      "  }",
      "",
      "  // Batch conversions",
      "  static Either<${2:Domain}Failure, List<${1:User}>> dtosToEntities(",
      "    List<${3:User}Dto> dtos,",
      "  ) {",
      "    final entities = <${1:User}>[];",
      "    ",
      "    for (int i = 0; i < dtos.length; i++) {",
      "      final result = dtoToEntity(dtos[i]);",
      "      if (result.isLeft()) {",
      "        return result.fold(",
      "          (failure) => left(${2:Domain}Failure.parsingError(",
      "            'Failed to parse item at index \\$i: \\${failure.message}',",
      "          )),",
      "          (_) => throw Exception('Unexpected state'),",
      "        );",
      "      }",
      "      ",
      "      result.fold(",
      "        (_) => throw Exception('Unexpected state'),",
      "        (entity) => entities.add(entity),",
      "      );",
      "    }",
      "    ",
      "    return right(entities);",
      "  }",
      "",
      "  static List<${3:User}Dto> entitiesToDtos(List<${1:User}> entities) {",
      "    return entities.map(entityToDto).toList();",
      "  }",
      "",
      "  // Safe conversion with fallback",
      "  static ${1:User}? safeDtoToEntity(${3:User}Dto dto) {",
      "    final result = dtoToEntity(dto);",
      "    return result.fold(",
      "      (_) => null,",
      "      (entity) => entity,",
      "    );",
      "  }",
      "",
      "  // Partial update mapping",
      "  static ${3:User}Dto updateDtoFromEntity(",
      "    ${3:User}Dto originalDto,",
      "    ${1:User} updatedEntity,",
      "  ) {",
      "    return originalDto.copyWith(",
      "      name: updatedEntity.name,",
      "      email: updatedEntity.email,",
      "      updatedAt: updatedEntity.updatedAt?.toIso8601String(),",
      "    );",
      "  }",
      "",
      "  // Validation helper",
      "  static bool isValidDto(${3:User}Dto dto) {",
      "    return dto.id.trim().isNotEmpty &&",
      "        dto.name.trim().isNotEmpty &&",
      "        dto.email.trim().isNotEmpty &&",
      "        DateTime.tryParse(dto.createdAt) != null &&",
      "        (dto.updatedAt == null || DateTime.tryParse(dto.updatedAt!) != null);",
      "  }",
      "",
      "  // Merge DTOs (useful for partial updates)",
      "  static ${3:User}Dto mergeDtos(",
      "    ${3:User}Dto base,",
      "    ${3:User}Dto updates,",
      "  ) {",
      "    return base.copyWith(",
      "      name: updates.name.isNotEmpty ? updates.name : base.name,",
      "      email: updates.email.isNotEmpty ? updates.email : base.email,",
      "      updatedAt: updates.updatedAt ?? DateTime.now().toIso8601String(),",
      "    );",
      "  }",
      "}",
      "$0"
    ]
  },

  "API Response DTO": {
    "prefix": "clean-api-response",
    "description": "Generic API response DTO with error handling",
    "body": [
      "import 'package:freezed_annotation/freezed_annotation.dart';",
      "",
      "part 'api_response.freezed.dart';",
      "part 'api_response.g.dart';",
      "",
      "@Freezed(genericArgumentFactories: true)",
      "class ApiResponse<T> with _\\$ApiResponse<T> {",
      "  const factory ApiResponse.success({",
      "    required T data,",
      "    String? message,",
      "    @JsonKey(name: 'status_code') @Default(200) int statusCode,",
      "    @Default(<String, dynamic>{}) Map<String, dynamic> metadata,",
      "  }) = ApiResponseSuccess<T>;",
      "",
      "  const factory ApiResponse.error({",
      "    required String message,",
      "    @JsonKey(name: 'error_code') String? errorCode,",
      "    @JsonKey(name: 'status_code') @Default(400) int statusCode,",
      "    @Default(<String, dynamic>{}) Map<String, dynamic> details,",
      "    @JsonKey(name: 'error_details') List<ErrorDetail>? errorDetails,",
      "  }) = ApiResponseError<T>;",
      "",
      "  factory ApiResponse.fromJson(",
      "    Map<String, dynamic> json,",
      "    T Function(Object?) fromJsonT,",
      "  ) =>",
      "      _\\$ApiResponseFromJson(json, fromJsonT);",
      "}",
      "",
      "@freezed",
      "class ErrorDetail with _\\$ErrorDetail {",
      "  const factory ErrorDetail({",
      "    required String field,",
      "    required String message,",
      "    @JsonKey(name: 'error_code') String? errorCode,",
      "  }) = _ErrorDetail;",
      "",
      "  factory ErrorDetail.fromJson(Map<String, dynamic> json) =>",
      "      _\\$ErrorDetailFromJson(json);",
      "}",
      "",
      "@freezed",
      "class PaginatedApiResponse<T> with _\\$PaginatedApiResponse<T> {",
      "  const factory PaginatedApiResponse({",
      "    required List<T> data,",
      "    required PaginationMeta pagination,",
      "    String? message,",
      "    @JsonKey(name: 'status_code') @Default(200) int statusCode,",
      "  }) = _PaginatedApiResponse<T>;",
      "",
      "  factory PaginatedApiResponse.fromJson(",
      "    Map<String, dynamic> json,",
      "    T Function(Object?) fromJsonT,",
      "  ) =>",
      "      _\\$PaginatedApiResponseFromJson(json, fromJsonT);",
      "}",
      "",
      "@freezed",
      "class PaginationMeta with _\\$PaginationMeta {",
      "  const factory PaginationMeta({",
      "    @JsonKey(name: 'current_page') required int currentPage,",
      "    @JsonKey(name: 'per_page') required int perPage,",
      "    @JsonKey(name: 'total_items') required int totalItems,",
      "    @JsonKey(name: 'total_pages') required int totalPages,",
      "    @JsonKey(name: 'has_next_page') required bool hasNextPage,",
      "    @JsonKey(name: 'has_previous_page') required bool hasPreviousPage,",
      "  }) = _PaginationMeta;",
      "",
      "  factory PaginationMeta.fromJson(Map<String, dynamic> json) =>",
      "      _\\$PaginationMetaFromJson(json);",
      "}",
      "",
      "// Extension methods for easier handling",
      "extension ApiResponseX<T> on ApiResponse<T> {",
      "  bool get isSuccess => when(",
      "        success: (_, __, ___, ____) => true,",
      "        error: (_, __, ___, ____, _____) => false,",
      "      );",
      "",
      "  bool get isError => !isSuccess;",
      "",
      "  T? get dataOrNull => when(",
      "        success: (data, _, __, ___) => data,",
      "        error: (_, __, ___, ____, _____) => null,",
      "      );",
      "",
      "  String get messageOrEmpty => when(",
      "        success: (_, message, __, ___) => message ?? '',",
      "        error: (message, _, __, ___, ____) => message,",
      "      );",
      "",
      "  int get code => when(",
      "        success: (_, __, statusCode, ___) => statusCode,",
      "        error: (_, __, statusCode, ___, ____) => statusCode,",
      "      );",
      "",
      "  bool get isClientError => code >= 400 && code < 500;",
      "",
      "  bool get isServerError => code >= 500;",
      "",
      "  bool get isNetworkError => code == 0 || code == -1;",
      "}",
      "",
      "// Helper class for API response parsing",
      "class ApiResponseParser {",
      "  static ApiResponse<T> parse<T>(",
      "    Map<String, dynamic> json,",
      "    T Function(Map<String, dynamic>) fromJson,",
      "  ) {",
      "    try {",
      "      if (json.containsKey('error') || json.containsKey('message')) {",
      "        return ApiResponse.error(",
      "          message: json['message'] ?? json['error'] ?? 'Unknown error',",
      "          errorCode: json['error_code'],",
      "          statusCode: json['status_code'] ?? 400,",
      "          details: json['details'] ?? {},",
      "          errorDetails: (json['error_details'] as List<dynamic>?)",
      "              ?.map((e) => ErrorDetail.fromJson(e as Map<String, dynamic>))",
      "              .toList(),",
      "        );",
      "      }",
      "",
      "      return ApiResponse.success(",
      "        data: fromJson(json['data'] ?? json),",
      "        message: json['message'],",
      "        statusCode: json['status_code'] ?? 200,",
      "        metadata: json['metadata'] ?? {},",
      "      );",
      "    } catch (e) {",
      "      return ApiResponse.error(",
      "        message: 'Failed to parse response: \\$e',",
      "        statusCode: 422,",
      "      );",
      "    }",
      "  }",
      "",
      "  static PaginatedApiResponse<T> parsePaginated<T>(",
      "    Map<String, dynamic> json,",
      "    T Function(Map<String, dynamic>) fromJson,",
      "  ) {",
      "    try {",
      "      final dataList = (json['data'] as List<dynamic>)",
      "          .map((item) => fromJson(item as Map<String, dynamic>))",
      "          .toList();",
      "",
      "      return PaginatedApiResponse(",
      "        data: dataList,",
      "        pagination: PaginationMeta.fromJson(",
      "          json['pagination'] as Map<String, dynamic>,",
      "        ),",
      "        message: json['message'],",
      "        statusCode: json['status_code'] ?? 200,",
      "      );",
      "    } catch (e) {",
      "      throw Exception('Failed to parse paginated response: \\$e');",
      "    }",
      "  }",
      "}",
      "$0"
    ]
  }
}
