{
  "Entity Class": {
    "prefix": "clean-entity",
    "description": "Complete Entity class with validation and business rules",
    "body": [
      "import 'package:equatable/equatable.dart';",
      "",
      "class ${1:User} extends Equatable {",
      "  final ${2:String} ${3:id};",
      "  final ${4:String} ${5:name};",
      "  final ${6:String} ${7:email};",
      "  final ${8:DateTime} ${9:createdAt};",
      "  final ${10:DateTime?} ${11:updatedAt};",
      "",
      "  const ${1:User}({",
      "    required this.${3:id},",
      "    required this.${5:name},",
      "    required this.${7:email},",
      "    required this.${9:createdAt},",
      "    this.${11:updatedAt},",
      "  });",
      "",
      "  // Business rules validation",
      "  bool get isValidEmail => RegExp(",
      "    r'^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$',",
      "  ).hasMatch(${7:email});",
      "",
      "  bool get hasValidName => ${5:name}.trim().length >= 2;",
      "",
      "  bool get isActive => ${11:updatedAt} != null &&",
      "    DateTime.now().difference(${11:updatedAt}!).inDays <= 30;",
      "",
      "  // Domain logic methods",
      "  ${1:User} updateProfile({",
      "    ${4:String}? ${5:name},",
      "    ${6:String}? ${7:email},",
      "  }) {",
      "    return ${1:User}(",
      "      ${3:id}: ${3:id},",
      "      ${5:name}: ${5:name} ?? this.${5:name},",
      "      ${7:email}: ${7:email} ?? this.${7:email},",
      "      ${9:createdAt}: ${9:createdAt},",
      "      ${11:updatedAt}: DateTime.now(),",
      "    );",
      "  }",
      "",
      "  ${1:User} markAsUpdated() {",
      "    return ${1:User}(",
      "      ${3:id}: ${3:id},",
      "      ${5:name}: ${5:name},",
      "      ${7:email}: ${7:email},",
      "      ${9:createdAt}: ${9:createdAt},",
      "      ${11:updatedAt}: DateTime.now(),",
      "    );",
      "  }",
      "",
      "  @override",
      "  List<Object?> get props => [",
      "    ${3:id},",
      "    ${5:name},",
      "    ${7:email},",
      "    ${9:createdAt},",
      "    ${11:updatedAt},",
      "  ];",
      "",
      "  @override",
      "  String toString() => '${1:User}('",
      "    '${3:id}: \\$${3:id}, '",
      "    '${5:name}: \\$${5:name}, '",
      "    '${7:email}: \\$${7:email}, '",
      "    '${9:createdAt}: \\$${9:createdAt}, '",
      "    '${11:updatedAt}: \\$${11:updatedAt}'",
      "    ')';",
      "}",
      "$0"
    ]
  },

  "Value Object": {
    "prefix": "clean-valueobject",
    "description": "Value Object with validation and immutability",
    "body": [
      "import 'package:dartz/dartz.dart';",
      "import 'package:equatable/equatable.dart';",
      "",
      "import '../failures/value_failures.dart';",
      "",
      "class ${1:Email} extends Equatable {",
      "  final String _value;",
      "",
      "  const ${1:Email}._(this._value);",
      "",
      "  factory ${1:Email}.create(String value) {",
      "    return ${1:Email}._(value);",
      "  }",
      "",
      "  static Either<ValueFailure, ${1:Email}> fromString(String value) {",
      "    if (value.isEmpty) {",
      "      return left(const ValueFailure.empty('Email cannot be empty'));",
      "    }",
      "",
      "    final emailRegex = RegExp(",
      "      r'^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$',",
      "    );",
      "",
      "    if (!emailRegex.hasMatch(value)) {",
      "      return left(const ValueFailure.invalidFormat('Invalid email format'));",
      "    }",
      "",
      "    if (value.length > 254) {",
      "      return left(const ValueFailure.tooLong('Email is too long'));",
      "    }",
      "",
      "    return right(${1:Email}._(value));",
      "  }",
      "",
      "  String get value => _value;",
      "",
      "  String get domain => _value.split('@')[1];",
      "",
      "  String get localPart => _value.split('@')[0];",
      "",
      "  bool get isGmail => domain.toLowerCase().contains('gmail.com');",
      "",
      "  bool get isCorporate => !['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com']",
      "      .contains(domain.toLowerCase());",
      "",
      "  @override",
      "  List<Object> get props => [_value];",
      "",
      "  @override",
      "  String toString() => _value;",
      "}",
      "$0"
    ]
  },

  "Domain Failure": {
    "prefix": "clean-failure",
    "description": "Complete Failure class with different error types",
    "body": [
      "import 'package:freezed_annotation/freezed_annotation.dart';",
      "",
      "part '${1:domain}_failure.freezed.dart';",
      "",
      "@freezed",
      "class ${2:Domain}Failure with _\\$${2:Domain}Failure {",
      "  // Network failures",
      "  const factory ${2:Domain}Failure.networkError([String? message]) = _NetworkError;",
      "  const factory ${2:Domain}Failure.connectionTimeout() = _ConnectionTimeout;",
      "  const factory ${2:Domain}Failure.noInternetConnection() = _NoInternetConnection;",
      "",
      "  // Server failures",
      "  const factory ${2:Domain}Failure.serverError({",
      "    required int statusCode,",
      "    String? message,",
      "  }) = _ServerError;",
      "  const factory ${2:Domain}Failure.unauthorizedAccess() = _UnauthorizedAccess;",
      "  const factory ${2:Domain}Failure.forbidden() = _Forbidden;",
      "  const factory ${2:Domain}Failure.notFound(String resource) = _NotFound;",
      "",
      "  // Business logic failures",
      "  const factory ${2:Domain}Failure.validationError({",
      "    required String field,",
      "    required String message,",
      "  }) = _ValidationError;",
      "  const factory ${2:Domain}Failure.businessRuleViolation(String rule) = _BusinessRuleViolation;",
      "  const factory ${2:Domain}Failure.conflictError(String message) = _ConflictError;",
      "",
      "  // Data failures",
      "  const factory ${2:Domain}Failure.parsingError(String data) = _ParsingError;",
      "  const factory ${2:Domain}Failure.cacheError() = _CacheError;",
      "  const factory ${2:Domain}Failure.databaseError(String operation) = _DatabaseError;",
      "",
      "  // Generic failures",
      "  const factory ${2:Domain}Failure.unexpected([String? message]) = _Unexpected;",
      "  const factory ${2:Domain}Failure.cancelled() = _Cancelled;",
      "}",
      "",
      "extension ${2:Domain}FailureX on ${2:Domain}Failure {",
      "  String get message {",
      "    return when(",
      "      networkError: (message) => message ?? 'Network error occurred',",
      "      connectionTimeout: () => 'Connection timeout',",
      "      noInternetConnection: () => 'No internet connection',",
      "      serverError: (statusCode, message) => ",
      "        message ?? 'Server error (\\$statusCode)',",
      "      unauthorizedAccess: () => 'Unauthorized access',",
      "      forbidden: () => 'Access forbidden',",
      "      notFound: (resource) => '\\$resource not found',",
      "      validationError: (field, message) => '\\$field: \\$message',",
      "      businessRuleViolation: (rule) => 'Business rule violation: \\$rule',",
      "      conflictError: (message) => 'Conflict: \\$message',",
      "      parsingError: (data) => 'Failed to parse data: \\$data',",
      "      cacheError: () => 'Cache operation failed',",
      "      databaseError: (operation) => 'Database \\$operation failed',",
      "      unexpected: (message) => message ?? 'Unexpected error occurred',",
      "      cancelled: () => 'Operation was cancelled',",
      "    );",
      "  }",
      "",
      "  bool get isNetworkRelated {",
      "    return when(",
      "      networkError: (_) => true,",
      "      connectionTimeout: () => true,",
      "      noInternetConnection: () => true,",
      "      serverError: (_, __) => true,",
      "      orElse: () => false,",
      "    );",
      "  }",
      "",
      "  bool get isRetryable {",
      "    return when(",
      "      networkError: (_) => true,",
      "      connectionTimeout: () => true,",
      "      noInternetConnection: () => true,",
      "      serverError: (statusCode, _) => statusCode >= 500,",
      "      cacheError: () => true,",
      "      orElse: () => false,",
      "    );",
      "  }",
      "}",
      "$0"
    ]
  },

  "Repository Interface": {
    "prefix": "clean-repository",
    "description": "Repository interface with comprehensive CRUD operations",
    "body": [
      "import 'package:dartz/dartz.dart';",
      "",
      "import '../entities/${1:user}.dart';",
      "import '../failures/${2:domain}_failure.dart';",
      "",
      "abstract class ${3:User}Repository {",
      "  // CRUD Operations",
      "  Future<Either<${2:Domain}Failure, ${1:User}>> create(${1:User} ${4:user});",
      "  Future<Either<${2:Domain}Failure, ${1:User}>> getById(String id);",
      "  Future<Either<${2:Domain}Failure, List<${1:User}>>> getAll();",
      "  Future<Either<${2:Domain}Failure, ${1:User}>> update(${1:User} ${4:user});",
      "  Future<Either<${2:Domain}Failure, Unit>> delete(String id);",
      "",
      "  // Query Operations",
      "  Future<Either<${2:Domain}Failure, List<${1:User}>>> search({",
      "    String? query,",
      "    Map<String, dynamic>? filters,",
      "    String? sortBy,",
      "    bool ascending = true,",
      "    int? limit,",
      "    int? offset,",
      "  });",
      "",
      "  Future<Either<${2:Domain}Failure, ${1:User}?>> findByEmail(String email);",
      "  Future<Either<${2:Domain}Failure, List<${1:User}>>> getActive();",
      "  Future<Either<${2:Domain}Failure, List<${1:User}>>> getRecent({int days = 7});",
      "",
      "  // Pagination",
      "  Future<Either<${2:Domain}Failure, PaginatedResult<${1:User}>>> getPaginated({",
      "    required int page,",
      "    required int pageSize,",
      "    String? sortBy,",
      "    bool ascending = true,",
      "    Map<String, dynamic>? filters,",
      "  });",
      "",
      "  // Batch Operations",
      "  Future<Either<${2:Domain}Failure, List<${1:User}>>> createMany(List<${1:User}> ${5:users});",
      "  Future<Either<${2:Domain}Failure, Unit>> deleteMany(List<String> ids);",
      "  Future<Either<${2:Domain}Failure, List<${1:User}>>> updateMany(List<${1:User}> ${5:users});",
      "",
      "  // Existence checks",
      "  Future<Either<${2:Domain}Failure, bool>> exists(String id);",
      "  Future<Either<${2:Domain}Failure, bool>> existsByEmail(String email);",
      "",
      "  // Stream operations for real-time updates",
      "  Stream<Either<${2:Domain}Failure, ${1:User}>> watchById(String id);",
      "  Stream<Either<${2:Domain}Failure, List<${1:User}>>> watchAll();",
      "  Stream<Either<${2:Domain}Failure, List<${1:User}>>> watchActive();",
      "",
      "  // Statistics and aggregations",
      "  Future<Either<${2:Domain}Failure, int>> count([Map<String, dynamic>? filters]);",
      "  Future<Either<${2:Domain}Failure, Map<String, int>>> getStatistics();",
      "}",
      "",
      "class PaginatedResult<T> {",
      "  final List<T> items;",
      "  final int totalCount;",
      "  final int page;",
      "  final int pageSize;",
      "  final int totalPages;",
      "  final bool hasNextPage;",
      "  final bool hasPreviousPage;",
      "",
      "  const PaginatedResult({",
      "    required this.items,",
      "    required this.totalCount,",
      "    required this.page,",
      "    required this.pageSize,",
      "  }) : totalPages = (totalCount / pageSize).ceil(),",
      "       hasNextPage = page < (totalCount / pageSize).ceil(),",
      "       hasPreviousPage = page > 1;",
      "}",
      "$0"
    ]
  },

  "Use Case Base": {
    "prefix": "clean-usecase-base",
    "description": "Base Use Case class with common functionality",
    "body": [
      "import 'package:dartz/dartz.dart';",
      "import 'package:equatable/equatable.dart';",
      "",
      "import '../failures/${1:domain}_failure.dart';",
      "",
      "abstract class UseCase<Type, Params> {",
      "  Future<Either<${2:Domain}Failure, Type>> call(Params params);",
      "}",
      "",
      "abstract class StreamUseCase<Type, Params> {",
      "  Stream<Either<${2:Domain}Failure, Type>> call(Params params);",
      "}",
      "",
      "abstract class SyncUseCase<Type, Params> {",
      "  Either<${2:Domain}Failure, Type> call(Params params);",
      "}",
      "",
      "class NoParams extends Equatable {",
      "  const NoParams();",
      "",
      "  @override",
      "  List<Object> get props => [];",
      "}",
      "",
      "abstract class PaginationParams extends Equatable {",
      "  final int page;",
      "  final int pageSize;",
      "  final String? sortBy;",
      "  final bool ascending;",
      "  final Map<String, dynamic>? filters;",
      "",
      "  const PaginationParams({",
      "    required this.page,",
      "    required this.pageSize,",
      "    this.sortBy,",
      "    this.ascending = true,",
      "    this.filters,",
      "  });",
      "",
      "  @override",
      "  List<Object?> get props => [",
      "        page,",
      "        pageSize,",
      "        sortBy,",
      "        ascending,",
      "        filters,",
      "      ];",
      "}",
      "",
      "abstract class SearchParams extends Equatable {",
      "  final String? query;",
      "  final Map<String, dynamic>? filters;",
      "  final String? sortBy;",
      "  final bool ascending;",
      "  final int? limit;",
      "  final int? offset;",
      "",
      "  const SearchParams({",
      "    this.query,",
      "    this.filters,",
      "    this.sortBy,",
      "    this.ascending = true,",
      "    this.limit,",
      "    this.offset,",
      "  });",
      "",
      "  @override",
      "  List<Object?> get props => [",
      "        query,",
      "        filters,",
      "        sortBy,",
      "        ascending,",
      "        limit,",
      "        offset,",
      "      ];",
      "}",
      "$0"
    ]
  }
}
